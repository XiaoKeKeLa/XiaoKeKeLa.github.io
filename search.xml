<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>随机快排</title>
      <link href="2020/10/21/%E9%9A%8F%E6%9C%BA%E5%BF%AB%E6%8E%92/"/>
      <url>2020/10/21/%E9%9A%8F%E6%9C%BA%E5%BF%AB%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<p>快排在选取主元的时候，每次都选取最右边的元素。当序列为有序时，会发现划分出来的两个子序列一个里面没有元素，而另一个则只比原来少一个元素。为了避免这种情况，引入一个随机化量来破坏这种有序状态。</p><p>在随机化的快排里面，选取a[left..right]中的随机一个元素作为主元，然后再进行划分，就可以得到一个平衡的划分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> random(x) rand()%(x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">t=a[n];</span><br><span class="line">a[n]=a[m];</span><br><span class="line">a[m]=t;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">int</span> * <span class="title">partition</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> less=L<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> more=R;</span><br><span class="line"><span class="keyword">while</span>(L&lt;more)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[L]&lt;a[R])</span><br><span class="line">swap(a,++less,L++);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[L]&gt;a[R])</span><br><span class="line">swap(a,L,--more);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[L]==a[R]) </span><br><span class="line">&#123; </span><br><span class="line">L++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(a,more,R);</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">2</span>]=&#123;less+<span class="number">1</span>,more&#125;;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L&lt;R)</span><br><span class="line">&#123;</span><br><span class="line">swap(a,random(R-L+<span class="number">1</span>),R);<span class="comment">//与经典快排不同，随机在数组中选择一个数字进行比较 </span></span><br><span class="line"><span class="keyword">int</span> *p=partition(a,L,R);</span><br><span class="line">quicksort(a,L,p[<span class="number">0</span>]<span class="number">-1</span>);</span><br><span class="line">quicksort(a,p[<span class="number">1</span>]+<span class="number">1</span>,R);</span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"> <span class="keyword">int</span> a[n];</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"> &#125;</span><br><span class="line"> quicksort(a,<span class="number">0</span>,n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>多次实验结果：</p><p><strong>10w：</strong></p><table><thead><tr><th>算法</th><th>第1次耗时</th><th>第2次耗时</th><th>第3次耗时</th><th>平均耗时</th></tr></thead><tbody><tr><td>普通快排</td><td>13ms</td><td>15ms</td><td>15ms</td><td>14.333ms</td></tr><tr><td>随机化版本快排</td><td>25ms</td><td>25ms</td><td>27ms</td><td>25.667ms</td></tr></tbody></table><p><strong>100w：</strong></p><table><thead><tr><th>算法</th><th>第1次耗时</th><th>第2次耗时</th><th>第3次耗时</th><th>平均耗时</th></tr></thead><tbody><tr><td>普通快排</td><td>101ms</td><td>103ms</td><td>96ms</td><td>100ms</td></tr><tr><td>随机化版本快排</td><td>119ms</td><td>101ms</td><td>105ms</td><td>108.333ms</td></tr></tbody></table><p><strong>1000w：</strong></p><table><thead><tr><th>算法</th><th>第1次耗时</th><th>第2次耗时</th><th>第3次耗时</th><th>平均耗时</th></tr></thead><tbody><tr><td>普通快排</td><td>1397ms</td><td>1379ms</td><td>1338ms</td><td>1371.333ms</td></tr><tr><td>随机化版本快排</td><td>1241ms</td><td>1187ms</td><td>1258ms</td><td>1228.667ms</td></tr></tbody></table><p>随机化快排因为要生成随机数，所以有一些性能损失，所以数据规模较小，数据分布均匀时普通快排还是比随机化快排要快些的，不过随着数据规模的上升，随机化快排的性能优势就展现出来了。</p><p><strong>有序序列</strong></p><p>下来才是展示快排才华的时候，假设当输入数组已经是排好序的，这两个算法的性能差距又有多少？<br>之前的数组生成代码不变，只是在调用两个算法之前，先调用一下快排将数组排序，然后将两个有序的数组作为参数传进去。</p><p><strong>10w：</strong></p><p>10w的普通快排……已经栈溢出了。</p><table><thead><tr><th>算法</th><th>第1次耗时</th><th>第2次耗时</th><th>第3次耗时</th><th>平均耗时</th></tr></thead><tbody><tr><td>普通快排</td><td>溢出</td><td>溢出</td><td>溢出</td><td>溢出</td></tr><tr><td>随机化版本快排</td><td>15ms</td><td>7ms</td><td>6ms</td><td>9.333ms</td></tr></tbody></table><p><strong>1w：</strong></p><p>试一试1w的</p><table><thead><tr><th>算法</th><th>第1次耗时</th><th>第2次耗时</th><th>第3次耗时</th><th>平均耗时</th></tr></thead><tbody><tr><td>普通快排</td><td>98ms</td><td>94ms</td><td>92ms</td><td>94.667ms</td></tr><tr><td>随机化版本快排</td><td>2ms</td><td>1ms</td><td>0ms</td><td>1ms</td></tr></tbody></table><p><strong>1000w：</strong></p><p>看下1000w下随机化快排是否有影响</p><table><thead><tr><th>算法</th><th>第1次耗时</th><th>第2次耗时</th><th>第3次耗时</th><th>平均耗时</th></tr></thead><tbody><tr><td>随机化版本快排</td><td>696ms</td><td>733ms</td><td>689ms</td><td>706ms</td></tr></tbody></table><p><em>参考书籍：机械工业出版社 第三版<strong>《算法导论》</strong>部分内容引自原书</em></p>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Ray Tracing in a Weekend》学习笔记01</title>
      <link href="2020/10/18/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
      <url>2020/10/18/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
      
        <content type="html"><![CDATA[<p>一、前期准备工作</p><p>1.下载一个<a href="http://www.121down.com/soft/softview-42834.html">ppmview</a>，用来看效果图。</p><p>2.需要你会C/C++</p><p>二、学习小结</p><p>黑体标题是按原文的标题来的，简单的章节会自动跳动。</p><h4 id="2-Output-an-Image"><a href="#2-Output-an-Image" class="headerlink" title="2.Output an Image"></a><strong>2.Output an Image</strong></h4><p>介绍了一下PPM</p><p><img src="/pictures/RayTracing/01/7.png" alt="PPM"></p><p>作者给的main.c代码，运行结果就是输出一张简单的图片，运行结果见原书。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Image</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> r = <span class="keyword">double</span>(i) / (image_width<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> g = <span class="keyword">double</span>(j) / (image_height<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> b = <span class="number">0.25</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> ir = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * r);</span><br><span class="line">            <span class="keyword">int</span> ig = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * g);</span><br><span class="line">            <span class="keyword">int</span> ib = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * b);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ir &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ig &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ib &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有以下几个问题需要注意：</p><p>1.使用会auto报错。默认把auto当做声明为自动变量。（自动变量意为拥有自动的生命周期）。这是C++98的标准。可自行百度auto在c++中的使用。</p><p>解决办法：</p><p>版本：Dev-C++ 4.8.1及以上<br>找到：工具- &gt;编译选项- &gt;程序<br>对应项改为：g++ -std=c++11</p><p>2.直接运行作者的代码是看不到效果图的，通过使用 “**&gt;**” 重定向运算符来生成ppm文件(对着目录文件夹shift＋鼠标右键，选择powershell打开)，再用记事本打开ppm文件，按图示将编码改为UTF-8（这里也可以直接用notepad++修改更方便）。再将<a href="https://convertio.co/zh/txt-ppm/">txt文件转换为ppm格式</a>，就可以用PMView打开查看效果图。</p><p><img src="/pictures/RayTracing/01/2.png" alt="生成ppm文件"></p><p>记事本修改方法，较麻烦不推荐：</p><p><img src="/pictures/RayTracing/01/3.png" alt="记事本修改"></p><p>notepad++修改方法更简单：</p><p><img src="/pictures/RayTracing/01/image-20201015223955099.png" alt="notepad++修改"></p><p><img src="/pictures/RayTracing/01/4.png" alt="效果图"></p><h4 id="3-The-vec3-Class"><a href="#3-The-vec3-Class" class="headerlink" title="3.The vec3 Class"></a><strong>3.The vec3 Class</strong></h4><p>几乎所有的图形程序都有一些用于存储几何矢量和颜色的类。 在许多系统中，这些向量是4D（3D加上几何的齐次坐标，而RGB加上颜色的alpha透明通道）。 就我们的目的而言，三个坐标就足够了。 我们将对颜色，位置，方向，偏移量等使用相同的vec3类。</p><h5 id="3-1-Variables-and-Methods"><a href="#3-1-Variables-and-Methods" class="headerlink" title="3.1 Variables and Methods"></a><strong>3.1 Variables and Methods</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vec3.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> VEC3_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VEC3_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">sqrt</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vec3</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vec3() : e&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125; &#123;&#125;<span class="comment">//默认向量为(0,0,0)</span></span><br><span class="line">        vec3(<span class="keyword">double</span> e0, <span class="keyword">double</span> e1, <span class="keyword">double</span> e2) : e&#123;e0, e1, e2&#125; &#123;&#125;<span class="comment">//有初始值的向量</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">0</span>]; &#125;<span class="comment">//返回x值</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">1</span>]; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">z</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">2</span>]; &#125;</span><br><span class="line"></span><br><span class="line">        vec3 <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123; <span class="keyword">return</span> vec3(-e[<span class="number">0</span>], -e[<span class="number">1</span>], -e[<span class="number">2</span>]); &#125;<span class="comment">//重载-</span></span><br><span class="line">        <span class="keyword">double</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> e[i]; &#125;<span class="comment">//重载[]</span></span><br><span class="line">        <span class="keyword">double</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> e[i]; &#125;<span class="comment">//见注意事项</span></span><br><span class="line"></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> vec3 &amp;v) &#123;<span class="comment">//重载+=</span></span><br><span class="line">            e[<span class="number">0</span>] += v.e[<span class="number">0</span>];</span><br><span class="line">            e[<span class="number">1</span>] += v.e[<span class="number">1</span>];</span><br><span class="line">            e[<span class="number">2</span>] += v.e[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>*=(<span class="keyword">const</span> <span class="keyword">double</span> t) &#123;<span class="comment">//重载*=</span></span><br><span class="line">            e[<span class="number">0</span>] *= t;</span><br><span class="line">            e[<span class="number">1</span>] *= t;</span><br><span class="line">            e[<span class="number">2</span>] *= t;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>/=(<span class="keyword">const</span> <span class="keyword">double</span> t) &#123;<span class="comment">//重载/=</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span> *= <span class="number">1</span>/t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="comment">//返回向量长度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sqrt</span>(length_squared());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">length_squared</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e[<span class="number">0</span>]*e[<span class="number">0</span>] + e[<span class="number">1</span>]*e[<span class="number">1</span>] + e[<span class="number">2</span>]*e[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">double</span> e[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type aliases for vec3</span></span><br><span class="line"><span class="keyword">using</span> point3 = vec3;   <span class="comment">// 3D point</span></span><br><span class="line"><span class="keyword">using</span> color = vec3;    <span class="comment">// RGB color</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>注意事项：</p><p>C++中，const类型对象只能调用const成员函数，但非const类型对象对于重载了const和非const的函数，会优先调用非const函数。这也提醒我们对于确定不想改变的变量，一定要定义为const类型，防止调用了某个非const的成员函数改变了对象数据却没有发现！</p><p>一个类重载operator[] ()函数时，要重载operator[]两次，一个是const函数，一个是非const函数。const函数的返回值用按值传递，非const函数的返回值用引用。只实现一次重载，在某些情况下是会报错的。</p><h5 id="3-2-vec3-Utility-Functions"><a href="#3-2-vec3-Utility-Functions" class="headerlink" title="3.2 vec3 Utility Functions"></a><strong>3.2 vec3 Utility Functions</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vec3.h</span></span><br><span class="line"><span class="comment">// vec3 Utility Functions</span></span><br><span class="line"><span class="comment">//inline是C++关键字，在函数声明或定义中，函数返回类型前加上关键字inline，即可以把函数指定为内联函数。    这样可以解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题</span></span><br><span class="line"><span class="comment">//重载输出运算符&lt;&lt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; v.e[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载运算符+</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>+(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> vec3(u.e[<span class="number">0</span>] + v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] + v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] + v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载运算符-</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>-(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> vec3(u.e[<span class="number">0</span>] - v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] - v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] - v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载运算符*，vec*vec</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> vec3(u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载运算符*，double*vec</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">double</span> t, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> vec3(t*v.e[<span class="number">0</span>], t*v.e[<span class="number">1</span>], t*v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载运算符*，vec*double</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">const</span> vec3 &amp;v, <span class="keyword">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t * v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载运算符/，vec/double</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>/(vec3 v, <span class="keyword">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>/t) * v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义点乘函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dot</span><span class="params">(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>]</span><br><span class="line">         + u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>]</span><br><span class="line">         + u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义叉乘函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">cross</span><span class="params">(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> vec3(u.e[<span class="number">1</span>] * v.e[<span class="number">2</span>] - u.e[<span class="number">2</span>] * v.e[<span class="number">1</span>],</span><br><span class="line">                u.e[<span class="number">2</span>] * v.e[<span class="number">0</span>] - u.e[<span class="number">0</span>] * v.e[<span class="number">2</span>],</span><br><span class="line">                u.e[<span class="number">0</span>] * v.e[<span class="number">1</span>] - u.e[<span class="number">1</span>] * v.e[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义转换单位向量函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">unit_vector</span><span class="params">(vec3 v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v / v.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-Color-Utility-Functions"><a href="#3-3-Color-Utility-Functions" class="headerlink" title="3.3  Color Utility Functions"></a><strong>3.3  Color Utility Functions</strong></h5><p>新建一个color.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//color.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COLOR_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_color</span><span class="params">(<span class="built_in">std</span>::ostream &amp;out, color pixel_color)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Write the translated [0,255] value of each color component.</span></span><br><span class="line">    <span class="comment">//编写每个颜色分量的转换后的[0,255]值。</span></span><br><span class="line">    out &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * pixel_color.x()) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * pixel_color.y()) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * pixel_color.z()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>现在main.c函数就要改成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Image</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="comment">//把image的所有像素调用write_color</span></span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="keyword">double</span>(i)/(image_width<span class="number">-1</span>), <span class="keyword">double</span>(j)/(image_height<span class="number">-1</span>), <span class="number">0.25</span>)</span></span>;</span><br><span class="line">            write_color(<span class="built_in">std</span>::<span class="built_in">cout</span>, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Rays-a-Simple-Camera-and-Background"><a href="#4-Rays-a-Simple-Camera-and-Background" class="headerlink" title="4.   Rays, a Simple Camera, and Background"></a><strong>4.   Rays, a Simple Camera, and Background</strong></h4><h5 id="4-1-The-ray-Class"><a href="#4-1-The-ray-Class" class="headerlink" title="4.1  The ray Class"></a><strong>4.1  The ray Class</strong></h5><p>新建ray.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ray.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ray</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ray() &#123;&#125;</span><br><span class="line">        ray(<span class="keyword">const</span> point3&amp; origin, <span class="keyword">const</span> vec3&amp; direction)</span><br><span class="line">            : orig(origin), dir(direction)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">point3 <span class="title">origin</span><span class="params">()</span> <span class="keyword">const</span>  </span>&#123; <span class="keyword">return</span> orig; &#125;</span><br><span class="line">        <span class="function">vec3 <span class="title">direction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> dir; &#125; </span><br><span class="line">        <span class="comment">//P（t）= A + tb</span></span><br><span class="line">        <span class="function">point3 <span class="title">at</span><span class="params">(<span class="keyword">double</span> t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> orig + t*dir;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        point3 orig;</span><br><span class="line">        vec3 dir;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h5 id="4-2-Sending-Rays-Into-the-Scene"><a href="#4-2-Sending-Rays-Into-the-Scene" class="headerlink" title="4.2  Sending Rays Into the Scene"></a><strong>4.2  Sending Rays Into the Scene</strong></h5><p>Now we are ready to turn the corner and make a ray tracer. <strong>At the core</strong>, the ray tracer sends rays through pixels and computes the color seen in the direction of those rays. The involved steps are <strong>(1) calculate the ray from the eye to the pixel, (2) determine which objects the ray intersects, and (3) compute a color for that intersection point.</strong></p><p>本文的项目是使用的是16:9的宽高比，坐标(0,0,0)放置的是摄像机位置（眼睛），四个蓝点确定屏幕。</p><p><img src="/pictures/RayTracing/01/fig-1.03-cam-geom.jpg" alt="坐标系示意图"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    vec3 unit_direction = unit_vector(r.direction());<span class="comment">//获得r的单位方向向量</span></span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.y() + <span class="number">1.0</span>);<span class="comment">//使得 0&lt;t&lt;1</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*color(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*color(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Image</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">//保证宽高比为16:9</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Camera</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;<span class="comment">//屏幕高度</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;<span class="comment">//屏幕宽度</span></span><br><span class="line">    <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;<span class="comment">//视距</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> origin = point3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//摄像机位置</span></span><br><span class="line">    <span class="keyword">auto</span> horizontal = vec3(viewport_width, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//屏幕水平方向最远点</span></span><br><span class="line">    <span class="keyword">auto</span> vertical = vec3(<span class="number">0</span>, viewport_height, <span class="number">0</span>);<span class="comment">//屏幕垂直方向最高点</span></span><br><span class="line">    <span class="comment">//lower_left_corner获得屏幕左下角的位置</span></span><br><span class="line">    <span class="keyword">auto</span> lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - vec3(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = <span class="keyword">double</span>(i) / (image_width<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> v = <span class="keyword">double</span>(j) / (image_height<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//从左下角开始，从下往上，从左向右，一行一行遍历</span></span><br><span class="line">            <span class="comment">//lower_left_corner + u*horizontal + v*vertical - origin  视线方向向量</span></span><br><span class="line">            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u*horizontal + v*vertical - origin)</span></span>;</span><br><span class="line">            color pixel_color = ray_color(r);</span><br><span class="line">            write_color(<span class="built_in">std</span>::<span class="built_in">cout</span>, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps:在将射线方向缩放到单位长度（因此-1.0 &lt;y &lt;1.0）之后，ray_color（ray）函数根据y坐标的高度线性混合白色和蓝色。 因为我们是在对向量进行归一化之后查看y高度，所以除了垂直渐变之外，您还会注意到颜色的水平渐变。<br>       然后，做了一个标准的图形技巧，将其缩放到0.0≤t≤1.0。 当t = 1.0时我想要蓝色。 当t = 0.0时我想要白色。 在这两者之间，我要混合。 这在两件事之间形成“线性混合”或“线性插值”或简称“ lerp”。  lerp总是形式<br>$$<br>blendedValue=(1−t)⋅startValue+t⋅endValue<br>$$<br>①确定分辨率，设定宽度image_width，通过宽高比算出高度image_width。相当于确定像素数量</p><p>②确定开始位置lower_left_corner，从viewport左下角开始计算，自下而上，自左向右，按行遍历。</p><p>③确定分辨率下的位置。lower_left_corner + u + v </p><p>④映射。要将分辨率下的位置转换到屏幕的屏幕坐标。例如分辨下的水平长度x=100。先将n=100/image_width-1，得到0&lt;n&lt;1，再将n * horizontal，就得到屏幕上的长度。lower_left_corner + u*horizontal + v *vertical</p><p>⑤最后再减去摄像机的位置，即可得到视线方向向量。</p><p>ray_color（const ray＆r）：将视线向量进行单位化，算出r的单位向量，将该向量的y，控制在（0,1）之间，通过线性差值的方法，使得图像出现渐变色。</p><p>write_color(std::ostream &amp;out, color pixel_color) ：pixel_color.x()乘255.999的目的就是把输出值控制在[0,255]之间，因为pixel_color.x()是在(0,1)之间。</p><p><img src="/pictures/RayTracing/01/image-20201016112514547.png" alt="效果图"></p><p>小总结：从viewport左下角开始计算，自下而上，自左向右，按行遍历像素。调用ray_color，计算光线在该像素的pixel_color。再调用write_color记录下该像素点的RGB。</p>]]></content>
      
      
      <categories>
          
          <category> Ray Tracing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="2020/10/12/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>2020/10/12/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-oVOyEpej" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1481164987" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#3F51B5"    ></div><p>堆是一种数据结构，一种叫做完全二叉树的数据结构。</p><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p><p>大顶堆：a[i] &gt;=a[2i+1] &amp;&amp; ar[i] &gt;= a[2i+2]  </p><p>小顶堆：a[i] &lt;= a[2i+1] &amp;&amp; a[i] &lt;= a[2i+2]  </p><p><strong>堆排序的基本思想：</strong></p><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p><p>算法思想：</p><p>1.把一组数据a[n]调整成大根堆或小根堆,用heapSize来实时记录数组尚未排序的数据的数量，初始值为a[n]长度n</p><p>2.将a[0]与a[–heapSize]交换值，因为一开始就把数据调整为大根堆，该步骤相当于把已经找出数组中最大的数据，并放到了最后一位，不再处理。</p><p>3.a[0]与a[–heapSize]交换值后，也破坏了大根堆，但除了a[0]以外，数组其他数据还是保持大根堆状态。此时就是一直将a[0]数据“下沉”，让他不断和孩子节点比较，直到找到孩子节点都比它小，停止“下沉”，被破坏了的大根堆又重新被调整为大根堆。不断–heapSize，不断调整大根堆，每次都把a[0]与a[–heapSize]交换值，最终数组有序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">t=a[n];</span><br><span class="line">a[n]=a[m];</span><br><span class="line">a[m]=t;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> index,<span class="keyword">int</span> heapsize)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span>(left&lt;heapsize)<span class="comment">//判断左孩子是否越界，若越界说明左孩子已经到达最下面 </span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">//比较两个孩子谁的值大 ，谁的值大谁就是largest </span></span><br><span class="line"> <span class="keyword">int</span> largest=left+<span class="number">1</span>&lt;heapsize&amp;&amp;a[left+<span class="number">1</span>]&gt;a[left]?left+<span class="number">1</span>:left;</span><br><span class="line"> <span class="comment">//比较父节点和孩子节点的大小</span></span><br><span class="line"> largest=a[largest]&gt;a[index]?largest:index; </span><br><span class="line"> <span class="keyword">if</span>(largest==index)<span class="comment">//若发现孩子节点都比a[index]小，则循环结束</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> swap(a,largest,index);</span><br><span class="line"> index=largest;</span><br><span class="line"> left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> index)</span><span class="comment">//把数组调成大根堆 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(a[index]&gt;a[(index<span class="number">-1</span>)/<span class="number">2</span>])</span><br><span class="line">&#123;</span><br><span class="line">swap(a,index,(index<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">index=(index<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="literal">NULL</span>||n&lt;<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">heapInsert(a,i);</span><br><span class="line"><span class="keyword">int</span> heapSize=n;</span><br><span class="line">swap(a,<span class="number">0</span>,--heapSize);<span class="comment">//交换后大根堆的最大的值到数组最后一个位置 </span></span><br><span class="line"><span class="keyword">while</span>(heapSize&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//每次都把数组中0-heapSize调整成大根堆 </span></span><br><span class="line">heapify(a,<span class="number">0</span>,heapSize);</span><br><span class="line">swap(a,<span class="number">0</span>,--heapSize);</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"> <span class="keyword">int</span> a[n];</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"> &#125;</span><br><span class="line"> heapSort(a,n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>荷兰国旗</title>
      <link href="2020/10/10/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97/"/>
      <url>2020/10/10/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数数组，给定一个值K，这个值在原数组中一定存在，要求把数组中小于K的元素放到数组的左边，大于K的元素放到数组的右边，等于K的元素放到数组的中间，最终返回一个整数数组，其中只有两个值，分别是等于K的数组部分的左右两个下标值。</p><p>例如，给定数组：[2, 3, 1, 9, 7, 6, 1, 4, 5]，给定一个值4，那么经过处理原数组可能得一种情况是：[2, 3, 1, 1, 4, 9, 7, 6, 5]， 需要注意的是，小于4的部分不需要有序，大于4的部分也不需要有序，返回等于4部分的左右两个下标，即[4, 4]</p><p>解析：有一点快排的思想。把数组分成三个区域，分别是less，equal，more。一直都是less区域推着equal区域挤压more区域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span><span class="comment">//交换数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">t=a[n];</span><br><span class="line">a[n]=a[m];</span><br><span class="line">a[m]=t;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> less=L<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> more=R+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(L&lt;more)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//L一直都是指向正在进行比较的数字 </span></span><br><span class="line"><span class="keyword">if</span>(a[L]&lt;num)<span class="comment">//如果小于num，less区域就要向右扩大，less++和L进行交换 </span></span><br><span class="line">swap(a,++less,L++);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[L]&gt;num)<span class="comment">//如果小于num，more区域就要向左扩大，--more和L进行交换 </span></span><br><span class="line">swap(a,L,--more);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[L]==num)<span class="comment">//如果等于num，则直接把L++，这样即可保证相等区域一直没有变动。 </span></span><br><span class="line">&#123; </span><br><span class="line">L++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n,num;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;num;</span><br><span class="line"> <span class="keyword">int</span> a[n];</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"> &#125;</span><br><span class="line"> partition(a,<span class="number">0</span>,n<span class="number">-1</span>,num);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆序对</title>
      <link href="2020/10/09/%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
      <url>2020/10/09/%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://www.nowcoder.com/questionTerminal/f50f89c3b4624cd6aa3312747cd45879">https://www.nowcoder.com/questionTerminal/f50f89c3b4624cd6aa3312747cd45879</a><br>来源：牛客网</p><p>给定一个长度为n的排列A,逆序的定义：(i,j)为逆序对，当i&lt;j &amp;&amp; A[i]&gt;A[j] </p><p>  求排列A的逆序对数量。 </p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行一个整数n，表示排列的长度.</span><br><span class="line">第二行n个元素，表示A排列.</span><br></pre></td></tr></table></figure><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出逆序对的数量</span><br></pre></td></tr></table></figure><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 2 4 1 5</span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>解析：原理是归并排序，在每次merge之前，比较左右两边的大小，若出现当i&lt;j &amp;&amp; A[i]&gt;A[j] ，则逆序对数量加一。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> L,<span class="keyword">int</span> mid,<span class="keyword">int</span> R)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> a[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;mergeSort(a,n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="literal">NULL</span>||n&lt;<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> sortProcess(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L&gt;=R)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid=L+((R-L)&gt;&gt;<span class="number">1</span>);<span class="comment">//相当于(L+R)/2,可有效避免溢出 </span></span><br><span class="line"><span class="keyword">return</span>sortProcess(a,L,mid)+sortProcess(a,mid+<span class="number">1</span>,R)+merge(a,L,mid,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> L,<span class="keyword">int</span> mid,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> help[R-L+<span class="number">1</span>];<span class="comment">//保存每次merge后的数组 </span></span><br><span class="line"><span class="built_in">memset</span>(help, <span class="number">0</span>, <span class="keyword">sizeof</span>(help));</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> p1=L;</span><br><span class="line"><span class="keyword">int</span> p2=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> rul=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p1&lt;=mid&amp;&amp;p2&lt;=R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//设任意p1&lt;m&lt;mid,当a[p1]&gt;a[p2]时，a[m]&lt;a[p2]也显然成立，m的数量为 mid-p1+1</span></span><br><span class="line"><span class="comment">//rul+=a[p1]&lt;=a[p2]?(R-p2+1)*a[p1]:0;</span></span><br><span class="line">rul+=a[p1]&gt;a[p2]?(mid-p1+<span class="number">1</span>):<span class="number">0</span>;</span><br><span class="line">help[i++]=a[p1]&lt;=a[p2]?a[p1++]:a[p2++];<span class="comment">//每次选择小的数字存入数组 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左右两边的数量不是每次都相等，将剩下的元素也添加到help数组中 </span></span><br><span class="line"><span class="keyword">while</span>(p1&lt;=mid)</span><br><span class="line">&#123;</span><br><span class="line">help[i++]=a[p1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(p2&lt;=R)</span><br><span class="line">&#123;</span><br><span class="line">help[i++]=a[p2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;R-L+<span class="number">1</span>;i++)</span><br><span class="line">a[L+i]=help[i];</span><br><span class="line"><span class="keyword">return</span> rul;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组小和</title>
      <link href="2020/10/08/%E6%95%B0%E7%BB%84%E5%B0%8F%E5%92%8C/"/>
      <url>2020/10/08/%E6%95%B0%E7%BB%84%E5%B0%8F%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://www.nowcoder.com/questionTerminal/edfe05a1d45c4ea89101d936cac32469">https://www.nowcoder.com/questionTerminal/edfe05a1d45c4ea89101d936cac32469</a><br>来源：牛客网</p><p>数组小和的定义如下： </p><p>  例如，数组s = [1, 3, 5, 2, 4, 6]，在s[0]的左边小于或等于s[0]的数的和为0；在s[1]的左边小于或等于s[1]的数的和为1；在s[2]的左边小于或等于s[2]的数的和为1+3=4；在s[3]的左边小于或等于s[3]的数的和为1； </p><p>  在s[4]的左边小于或等于s[4]的数的和为1+3+2=6；在s[5]的左边小于或等于s[5]的数的和为1+3+5+2+4=15。所以s的小和为0+1+4+1+6+15=27 </p><p>  给定一个数组s，实现函数返回s的小和 </p><p>   [要求]  </p><p>   时间复杂度为O(nlogn)，空间复杂度为O(n)  </p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行有一个整数N。表示数组长度</span><br><span class="line">接下来一行N个整数表示数组内的数</span><br></pre></td></tr></table></figure><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个整数表示答案</span><br></pre></td></tr></table></figure><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">1 3 5 2 4 6</span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">27</span><br></pre></td></tr></table></figure><h5 id="备注"><a href="#备注" class="headerlink" title="备注:"></a><strong>备注:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1⩽N⩽10^5</span><br><span class="line">−100⩽arri⩽100</span><br></pre></td></tr></table></figure><p>解：本质上是归并排序问题，只是在每次排序之前先检查出左边比右边小的数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> L,<span class="keyword">int</span> mid,<span class="keyword">int</span> R)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> a[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;mergeSort(a,n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="literal">NULL</span>||n&lt;<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> sortProcess(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L&gt;=R)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid=L+((R-L)&gt;&gt;<span class="number">1</span>);<span class="comment">//相当于(L+R)/2,可有效避免溢出 </span></span><br><span class="line"><span class="keyword">return</span>sortProcess(a,L,mid)+sortProcess(a,mid+<span class="number">1</span>,R)+merge(a,L,mid,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> L,<span class="keyword">int</span> mid,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> help[R-L+<span class="number">1</span>];<span class="comment">//保存每次merge后的数组 </span></span><br><span class="line"><span class="built_in">memset</span>(help, <span class="number">0</span>, <span class="keyword">sizeof</span>(help));</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> p1=L;</span><br><span class="line"><span class="keyword">int</span> p2=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> rul=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p1&lt;=mid&amp;&amp;p2&lt;=R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//设任意p2&lt;m&lt;R,当a[p1]&lt;=a[p2]时，a[p1]&lt;a[m]也显然成立，m的数量为 R-p2+1</span></span><br><span class="line">rul+=a[p1]&lt;=a[p2]?(R-p2+<span class="number">1</span>)*a[p1]:<span class="number">0</span>;</span><br><span class="line">help[i++]=a[p1]&lt;=a[p2]?a[p1++]:a[p2++];<span class="comment">//每次选择小的数字存入数组 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左右两边的数量不是每次都相等，将剩下的元素也添加到help数组中 </span></span><br><span class="line"><span class="keyword">while</span>(p1&lt;=mid)</span><br><span class="line">&#123;</span><br><span class="line">help[i++]=a[p1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(p2&lt;=R)</span><br><span class="line">&#123;</span><br><span class="line">help[i++]=a[p2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;R-L+<span class="number">1</span>;i++)</span><br><span class="line">a[L+i]=help[i];</span><br><span class="line"><span class="keyword">return</span> rul;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
