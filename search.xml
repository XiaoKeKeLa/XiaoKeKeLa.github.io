<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Qt学习笔记00--安装</title>
      <link href="2020/12/10/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
      <url>2020/12/10/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
      
        <content type="html"><![CDATA[<p>写在前面：</p><p>研一课程太多，每周都有考试！加上助教等乱七八糟的活，当然还有怠惰。最近一直没有学到什么实质性内容，OpenGL一直在学，但没有做笔记，因为<a href="https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/">LearnOpenGL</a>太强大了，我再做笔记没有记录意义，可能以后会记录我在实际使用过程遇到的问题和心得感受。</p><p>之前在学习wxWidget，但老板说我们用Qt开发，所以wxWidget学到那里就够我看懂论文的图形界面了，不用再深入了解，所以就有了Qt学习笔记开始了征程。</p><h4 id="一、下载Qt"><a href="#一、下载Qt" class="headerlink" title="一、下载Qt"></a>一、下载Qt</h4><p>从 Qt 5.15 开始，开源版本，无论是不是 LTS，都只能在线安装。</p><p>我采用的是Qt的在线安装。下载地址：<a href="http://download.qt.io/official_releases/online_installers/">http://download.qt.io/official_releases/online_installers/</a></p><h4 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h4><p>安装很简单，一直下一步。</p><p>几点提示：</p><p>1.账号登录问题</p><p><img src="/pictures/Qt/00/1.png" alt="安装界面"></p><p>我是注册并登录了Qt账号，目前还没有发现问题。网上有人说登录了账号过一个月后可能出现不能使用的问题，我还没有用到一个月，不知道是否会有问题。有尝试网上的教程，断网安装，但前面说了，从Qt5.15开始只能在线安装。有机会我再试试安装5.15以下的版本。</p><p>2.选择安装组件</p><p>这里最好是先了解清楚，你需要的开发环境，再安装，当然也可以全装上。</p><h4 id="三、设置环境变量"><a href="#三、设置环境变量" class="headerlink" title="三、设置环境变量"></a>三、设置环境变量</h4><p>把你的安装路径添加到系统变量的Path中</p><p><img src="/pictures/Qt/00/2.png" alt="添加环境变量"></p><p>这里的<strong>msvc2019_64</strong>就对应你要使用的版本。</p><h4 id="四、安装vs2019扩展"><a href="#四、安装vs2019扩展" class="headerlink" title="四、安装vs2019扩展"></a>四、安装vs2019扩展</h4><p>新建一个vs空白项目，在扩展-&gt;管理扩展里面搜索Qt，然后安装。根据提示下载完成后，关闭vs即可安装。</p><p>这时再新建一个vs项目就可以选择Qt应用。先新建一个Qt Widgets Application。项目名称就叫<code>MyFirstWidget</code></p><p><img src="/pictures/Qt/00/3.png" alt="安装Qt扩展"></p><p>在这个页面，选择QWidget，点击Finish</p><p><img src="/pictures/Qt/00/4.png" alt="新建Qt应用"></p><p>按照图示，找到Qt Options</p><p><img src="/pictures/Qt/00/5.png" alt="设置Qt"></p><p>点击Add，将安装的Qt路径添加进去，下图供参考路径Name：msvc2019_64，Path：msvc2019_64的所在位置，如果使用其他版本也是安装这样填写，把对应的name和path换了即可</p><p><img src="/pictures/Qt/00/6.png" alt="设置Qt"></p><p>到这里，Qt和vs2019就已经配置完成。</p><h4 id="五、问题"><a href="#五、问题" class="headerlink" title="五、问题"></a>五、问题</h4><p>我在完成上述步骤后，尝试写一点代码来练练手，出现了几个问题：</p><p>1.无法打开ui_MyFirstWidget.h</p><p><img src="/pictures/Qt/00/7.png" alt="无法打开ui_MyFirstWidget.h"></p><p>我的解决方案：</p><p>右键MyFirstWidget.ui，选择编译，然后右键MyFirstWidget选择重新扫描解决方案</p><p><img src="/pictures/Qt/00/8.png" alt="编译ui"></p><p><img src="/pictures/Qt/00/9.png" alt="重新扫描解决方案"></p><p>问题就解决了。。。</p><p>2.更改ui界面后，代码中无法调用</p><p>我在ui界面中添加了新控件lineText</p><p><img src="/pictures/Qt/00/10.png" alt="添加lineText"></p><p>我想在代码中调用控件的objetName，出现了下面这个问题</p><p><img src="/pictures/Qt/00/11.png" alt="无法调用objectName"></p><p>无法调用我新添加的控件的objetName</p><p>我的解决方案和第一个问题是一样的，都是先编译ui在重新扫描解决方案。</p><p>万事俱备，开始愉快学习Qt~</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL学习笔记02-简单入门</title>
      <link href="2020/12/01/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002-%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/"/>
      <url>2020/12/01/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002-%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>#define GLEW_STATIC 表示使用glew32s.lib</p>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Ray Tracing in a Weekend》学习笔记08</title>
      <link href="2020/11/27/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B008/"/>
      <url>2020/11/27/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B008/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-EuSCfXzn" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1383927243" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#3F51B5"    ></div><h4 id="11-Positionable-Camera"><a href="#11-Positionable-Camera" class="headerlink" title="11.Positionable Camera"></a>11.Positionable Camera</h4><p>像电介质一样，相机很难调试。 首先，让我们调整视野（<em>fov</em>）。 这是你通过门户看到的角度。 由于我们的图像不是方形的，因此水平和垂直方向的视场都不同。 我总是使用垂直视野。 我通常还会以度数指定它，并在构造函数中更改为弧度，这是个人喜好问题。</p><h5 id="11-1Camera-Viewing-Geometry"><a href="#11-1Camera-Viewing-Geometry" class="headerlink" title="11.1Camera Viewing Geometry"></a>11.1Camera Viewing Geometry</h5><p>首先，我使光线从原点发出并前进到z = -1平面。 只要使h与该距离成比例，就可以将其设为z = -2平面。 这是我们的设置：</p><p><img src="/pictures/RayTracing/08/1.png" alt="Camera viewing geometry"></p><p>这意味着<code>h = tan(θ/2)</code>。 现在，我们的相机变为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[camera.h] Camera with adjustable field-of-view (fov)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">camera</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        camera(</span><br><span class="line">            <span class="keyword">double</span> vfov, <span class="comment">// vertical field-of-view in degrees</span></span><br><span class="line">            <span class="keyword">double</span> aspect_ratio</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">auto</span> theta = degrees_to_radians(vfov);</span><br><span class="line">            <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">            <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">            origin = point3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            horizontal = vec3(viewport_width, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">            vertical = vec3(<span class="number">0.0</span>, viewport_height, <span class="number">0.0</span>);</span><br><span class="line">            lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - vec3(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="keyword">double</span> u, <span class="keyword">double</span> v)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ray(origin, lower_left_corner + u*horizontal + v*vertical - origin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        point3 origin;</span><br><span class="line">        point3 lower_left_corner;</span><br><span class="line">        vec3 horizontal;</span><br><span class="line">        vec3 vertical;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当使用相机<code>cam(90,Aspect_ratio)</code>和这些球体调用它时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[main.cc] Scene with wide-angle camera</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// World</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> R = <span class="built_in">cos</span>(pi/<span class="number">4</span>);</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material_left  = make_shared&lt;lambertian&gt;(color(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_right = make_shared&lt;lambertian&gt;(color(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    world.add(make_shared&lt;sphere&gt;(point3(-R, <span class="number">0</span>, <span class="number">-1</span>), R, material_left));</span><br><span class="line">    world.add(make_shared&lt;sphere&gt;(point3( R, <span class="number">0</span>, <span class="number">-1</span>), R, material_right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Camera</span></span><br><span class="line"></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(<span class="number">90.0</span>, aspect_ratio)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><img src="/pictures/RayTracing/08/2.png" alt="A wide-angle view"></p><h5 id="11-2-Positioning-and-Orienting-the-Camera"><a href="#11-2-Positioning-and-Orienting-the-Camera" class="headerlink" title="11.2 Positioning and Orienting the Camera"></a>11.2 Positioning and Orienting the Camera</h5><p>为了获得一个任意的观点，让我们先命名我们关心的点。 我们将其称为相机视线的放置位置，以及视线的视点。  （以后，如果需要，可以定义一个看向的方向，而不是要看的一个点。）</p><p>我们还需要一种方法来指定相机的侧倾或侧向倾斜：围绕lookat-lookfrom轴的旋转。 考虑它的另一种方法是，即使保持<code>lookfrom</code>和<code>looka</code>t不变，你仍然可以绕着鼻子旋转头。 我们需要一种为摄像机指定“向上”矢量的方法。 此向上向量应位于与视图方向正交的平面中。</p><p><img src="/pictures/RayTracing/08/3.png" alt="Camera view direction"></p><p>实际上，我们可以使用所需的任何向上矢量，并将其投影到此平面上即可为相机获取向上矢量。 我使用命名“查看”<code>（vup）</code>向量的通用约定。 几个交叉产品，现在我们有一个完整的正交基础<code>(u，v，w)</code>来描述相机的方向。</p><p><img src="/pictures/RayTracing/08/4.png" alt="Camera view up direction"></p><p>请记住，<code>vup</code>，<code>v</code>和<code>w</code>都在同一平面上。 请注意，就像之前固定摄像机面向-Z时一样，任意视图摄像机面向-w。 并且请记住，我们可以-但不是必须-使用world up<code>(0,1,0)</code>来指定vup。 这很方便，可以自然地使相机保持水平，直到你决定尝试疯狂的相机角度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[camera.h] Positionable and orientable camera</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">camera</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        camera(</span><br><span class="line">            point3 lookfrom,</span><br><span class="line">            point3 lookat,</span><br><span class="line">            vec3   vup,</span><br><span class="line">            <span class="keyword">double</span> vfov, <span class="comment">// vertical field-of-view in degrees</span></span><br><span class="line">            <span class="keyword">double</span> aspect_ratio</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">auto</span> theta = degrees_to_radians(vfov);</span><br><span class="line">            <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">            <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> w = unit_vector(lookfrom - lookat);</span><br><span class="line">            <span class="keyword">auto</span> u = unit_vector(cross(vup, w));</span><br><span class="line">            <span class="keyword">auto</span> v = cross(w, u);</span><br><span class="line"></span><br><span class="line">            origin = lookfrom;</span><br><span class="line">            horizontal = viewport_width * u;</span><br><span class="line">            vertical = viewport_height * v;</span><br><span class="line">            lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="keyword">double</span> s, <span class="keyword">double</span> t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ray(origin, lower_left_corner + s*horizontal + t*vertical - origin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        point3 origin;</span><br><span class="line">        point3 lower_left_corner;</span><br><span class="line">        vec3 horizontal;</span><br><span class="line">        vec3 vertical;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们将回到先前的场景，并使用新的视点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[main.c] Scene with alternate viewpoint</span></span><br><span class="line">hittable_list world;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> material_ground = make_shared&lt;lambertian&gt;(color(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line"><span class="keyword">auto</span> material_center = make_shared&lt;lambertian&gt;(color(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>));</span><br><span class="line"><span class="keyword">auto</span> material_left   = make_shared&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">auto</span> material_right  = make_shared&lt;metal&gt;(color(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">world.add(make_shared&lt;sphere&gt;(point3( <span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">world.add(make_shared&lt;sphere&gt;(point3( <span class="number">0.0</span>,    <span class="number">0.0</span>, <span class="number">-1.0</span>),   <span class="number">0.5</span>, material_center));</span><br><span class="line">world.add(make_shared&lt;sphere&gt;(point3(<span class="number">-1.0</span>,    <span class="number">0.0</span>, <span class="number">-1.0</span>),   <span class="number">0.5</span>, material_left));</span><br><span class="line">world.add(make_shared&lt;sphere&gt;(point3(<span class="number">-1.0</span>,    <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">-0.45</span>, material_left));</span><br><span class="line">world.add(make_shared&lt;sphere&gt;(point3( <span class="number">1.0</span>,    <span class="number">0.0</span>, <span class="number">-1.0</span>),   <span class="number">0.5</span>, material_right));</span><br><span class="line"></span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(point3(<span class="number">-2</span>,<span class="number">2</span>,<span class="number">1</span>), point3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), vec3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>), <span class="number">90</span>, aspect_ratio)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="/pictures/RayTracing/08/5.png" alt="A distant view"></p><p>我们可以更改视野：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[main.c] Change field of view</span></span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(point3(<span class="number">-2</span>,<span class="number">2</span>,<span class="number">1</span>), point3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), vec3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>), <span class="number">20</span>, aspect_ratio)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="/pictures/RayTracing/08/6.png" alt="Zooming in"></p><h4 id="12-Defocus-Blur"><a href="#12-Defocus-Blur" class="headerlink" title="12.Defocus Blur"></a>12.Defocus Blur</h4><p>我们在真实相机中散焦模糊的原因是，它们需要一个大孔（而不只是一个针孔）来收集光线。 这将使所有物体散焦，但是如果我们将镜头插入孔中，则所有物体都将聚焦一定距离。 你可以这样想一想镜头：来自特定点的焦点距离处的所有光线（入射到镜头）将被折回到图像传感器上的单个点。</p><p>我们称投影点与一切都处于完美聚焦的平面之间的距离为聚焦距离。 请注意，焦距与焦距不同—焦距是投影点与像平面之间的距离。</p><p>在物理相机中，聚焦距离由镜头与胶片/传感器之间的距离控制。 这就是为什么当你更改焦点时会看到镜头相对于相机移动的原因（这也可能发生在手机相机中，但传感器也会移动）。  “光圈”是一个孔，用于控制镜头的有效尺寸。 对于真正的相机，如果你需要更多的光线，则可以使光圈更大，并获得更多的散焦模糊。 对于我们的虚拟相机，我们可以拥有一个完美的传感器并且永远不需要更多的光线，因此只有当我们需要散焦模糊时才有一个光圈。</p><h5 id="12-1-A-Thin-Lens-Approximation"><a href="#12-1-A-Thin-Lens-Approximation" class="headerlink" title="12.1 A Thin Lens Approximation"></a>12.1 A Thin Lens Approximation</h5><p>真实的相机具有复杂的复合镜头。 对于我们的代码，我们可以模拟顺序：传感器，然后是镜头，然后是光圈。 然后我们可以找出将光线发送到哪里，并在计算出图像后翻转图像（图像上下颠倒地投影在胶片上）。 但是，图形用户通常使用薄透镜近似值：</p><p><img src="/pictures/RayTracing/08/7.png" alt="Camera lens model"></p><p>我们不需要模拟相机的任何内部。 为了在相机外部渲染图像，这将是不必要的复杂性。 取而代之的是，我通常从镜头开始发出光线，然后将它们发送到聚焦平面（离镜头较远的focus_dist），在那里该平面上的所有物体都处于完美聚焦状态。</p><p><img src="/pictures/RayTracing/08/8.png" alt="Camera focus plane"></p><h5 id="12-2-Generating-Sample-Rays"><a href="#12-2-Generating-Sample-Rays" class="headerlink" title="12.2 Generating Sample Rays"></a>12.2 Generating Sample Rays</h5><p>通常，所有场景射线均来自于视点。 为了实现散焦模糊，请生成以场景为中心的磁盘内部发出的随机场景光线。 半径越大，散焦模糊越大。 你可以认为我们的原始相机具有一个半径为零的散焦盘（完全没有模糊），因此所有光线都来自该盘中心（从视线开始）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[vec3.h] Generate random point inside unit disk</span></span><br><span class="line"><span class="function">vec3 <span class="title">random_in_unit_disk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = vec3(random_double(<span class="number">-1</span>,<span class="number">1</span>), random_double(<span class="number">-1</span>,<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.length_squared() &gt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[camera.h] Camera with adjustable depth-of-field (dof)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">camera</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        camera(</span><br><span class="line">            point3 lookfrom,</span><br><span class="line">            point3 lookat,</span><br><span class="line">            vec3   vup,</span><br><span class="line">            <span class="keyword">double</span> vfov, <span class="comment">// vertical field-of-view in degrees</span></span><br><span class="line">            <span class="keyword">double</span> aspect_ratio,</span><br><span class="line">            <span class="keyword">double</span> aperture,</span><br><span class="line">            <span class="keyword">double</span> focus_dist</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">auto</span> theta = degrees_to_radians(vfov);</span><br><span class="line">            <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">            <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line"></span><br><span class="line">            w = unit_vector(lookfrom - lookat);</span><br><span class="line">            u = unit_vector(cross(vup, w));</span><br><span class="line">            v = cross(w, u);</span><br><span class="line"></span><br><span class="line">            origin = lookfrom;</span><br><span class="line">            horizontal = focus_dist * viewport_width * u;</span><br><span class="line">            vertical = focus_dist * viewport_height * v;</span><br><span class="line">            lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - focus_dist*w;</span><br><span class="line"></span><br><span class="line">            lens_radius = aperture / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="keyword">double</span> s, <span class="keyword">double</span> t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            vec3 rd = lens_radius * random_in_unit_disk();</span><br><span class="line">            vec3 offset = u * rd.x() + v * rd.y();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ray(</span><br><span class="line">                origin + offset,</span><br><span class="line">                lower_left_corner + s*horizontal + t*vertical - origin - offset</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        point3 origin;</span><br><span class="line">        point3 lower_left_corner;</span><br><span class="line">        vec3 horizontal;</span><br><span class="line">        vec3 vertical;</span><br><span class="line">        vec3 u, v, w;</span><br><span class="line">        <span class="keyword">double</span> lens_radius;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用大光圈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[main.c] Scene camera with depth-of-field</span></span><br><span class="line"><span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dist_to_focus = (lookfrom-lookat).length();</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="/pictures/RayTracing/08/9.png" alt="Spheres with depth-of-field"></p><h4 id="13-Where-Next"><a href="#13-Where-Next" class="headerlink" title="13.Where Next?"></a>13.Where Next?</h4><h5 id="13-1-A-Final-Render"><a href="#13-1-A-Final-Render" class="headerlink" title="13.1 A Final Render"></a>13.1 A Final Render</h5><p>首先，让我们在本书的封面上制作图像-许多随机球体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[main.c] Final scene</span></span><br><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ground_material = make_shared&lt;lambertian&gt;(color(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line">    world.add(make_shared&lt;sphere&gt;(point3(<span class="number">0</span>,<span class="number">-1000</span>,<span class="number">0</span>), <span class="number">1000</span>, ground_material));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">-11</span>; b &lt; <span class="number">11</span>; b++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> choose_mat = random_double();</span><br><span class="line">            <span class="function">point3 <span class="title">center</span><span class="params">(a + <span class="number">0.9</span>*random_double(), <span class="number">0.2</span>, b + <span class="number">0.9</span>*random_double())</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((center - point3(<span class="number">4</span>, <span class="number">0.2</span>, <span class="number">0</span>)).length() &gt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                <span class="built_in">shared_ptr</span>&lt;material&gt; sphere_material;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.8</span>) &#123;</span><br><span class="line">                    <span class="comment">// diffuse</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = color::random() * color::random();</span><br><span class="line">                    sphere_material = make_shared&lt;lambertian&gt;(albedo);</span><br><span class="line">                    world.add(make_shared&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.95</span>) &#123;</span><br><span class="line">                    <span class="comment">// metal</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = color::random(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">auto</span> fuzz = random_double(<span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">                    sphere_material = make_shared&lt;metal&gt;(albedo, fuzz);</span><br><span class="line">                    world.add(make_shared&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// glass</span></span><br><span class="line">                    sphere_material = make_shared&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">                    world.add(make_shared&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material1 = make_shared&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    world.add(make_shared&lt;sphere&gt;(point3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material2 = make_shared&lt;lambertian&gt;(color(<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.1</span>));</span><br><span class="line">    world.add(make_shared&lt;sphere&gt;(point3(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material3 = make_shared&lt;metal&gt;(color(<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>), <span class="number">0.0</span>);</span><br><span class="line">    world.add(make_shared&lt;sphere&gt;(point3(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material3));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> world;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Image</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">3.0</span> / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">1200</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> samples_per_pixel = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> max_depth = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// World</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> world = random_scene();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Camera</span></span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">13</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> aperture = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pictures/RayTracing/08/10.png" alt="Final scene"></p><p>你可能会注意到的一件有趣的事是，玻璃球确实没有阴影，这使它们看起来像是漂浮的。 这不是错误-你在现实生活中看不到玻璃球，它们看起来也有些奇怪，并且确实似乎在阴天漂浮。 玻璃球下的大球体上的某个点仍然有很多光射向它，因为天空是重新排序的而不是被遮挡了。</p><p> 终于把《Ray Tracing in a Weekend》这本看完了。虽然后面几节没有很认真的阅读。研一的课程实在太多，没有集中的时间慢慢阅读。等再深入学一学图形学内容，再更新后续部分。接下来需要把c++的图形库搞清楚，为复现大佬论文做准备工作。</p><p>完结撒花<del>~</del></p>]]></content>
      
      
      <categories>
          
          <category> Ray Tracing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wxWidgets学习笔记02</title>
      <link href="2020/11/16/wxWidgets%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/"/>
      <url>2020/11/16/wxWidgets%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/</url>
      
        <content type="html"><![CDATA[<h2 id="Writing-Your-First-Application"><a href="#Writing-Your-First-Application" class="headerlink" title="Writing Your First Application"></a>Writing Your First Application</h2><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//base.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __BASE_H </span></span><br><span class="line"><span class="comment">// Make sure to only declare these classes once </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __BASE_H </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainApp</span>:</span> <span class="keyword">public</span> wxApp <span class="comment">// MainApp is the class for our application </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// MainApp just acts as a container for the window, or frame in MainFrame</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">OnInit</span><span class="params">()</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainFrame</span>:</span> <span class="keyword">public</span> wxFrame <span class="comment">// MainFrame is the class for our window, </span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">// It contains the window and all objects in it </span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">MainFrame(<span class="keyword">const</span> wxString &amp;title, <span class="keyword">const</span> wxPoint &amp;pos, <span class="keyword">const</span> wxSize &amp;size); </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">DECLARE_APP(MainApp)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//base.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wx/wxprec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WX_PRECOMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wx/wx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;base.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">IMPLEMENT_APP(MainApp) <span class="comment">// A macro that tells wxWidgets to create an instance of our application </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MainApp::OnInit</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Create an instance of our frame, or window </span></span><br><span class="line">MainFrame *MainWin = <span class="keyword">new</span> MainFrame(_(<span class="string">&quot;Hello World!&quot;</span>), wxDefaultPosition, wxSize(<span class="number">300</span>, <span class="number">200</span>));</span><br><span class="line">MainWin-&gt;Show(<span class="literal">true</span>); <span class="comment">// show the window </span></span><br><span class="line">SetTopWindow(MainWin); <span class="comment">// and finally, set it as the main window </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">MainFrame::MainFrame(<span class="keyword">const</span> wxString&amp; title, <span class="keyword">const</span> wxPoint&amp; pos, <span class="keyword">const</span> wxSize&amp; size) </span><br><span class="line">: wxFrame((wxFrame *) <span class="literal">NULL</span>, <span class="number">-1</span>, title, pos, size) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// normally we would initialize objects such as buttons and textboxes here </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pictures/wxWidgets/02/1.png" alt="运行结果"></p><p><strong>What Does This Code Do?</strong></p><p>wxApp类是应用程序本身。 它处理我们应用程序的属性，并检查事件（例如单击按钮）。 基本上，它控制着我们的应用程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainApp</span>:</span> <span class="keyword">public</span> wxApp <span class="comment">// MainApp is the class for our application</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// MainApp just acts as a container for the window, or frame in MainFrame</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">OnInit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>WxFrame是我们将要注意的主要类，wxFrame表示一个具有自己的宽度，高度，样式和对象的窗口。 这是你在启动该程序时看到的内容，尽管我们的内容非常空白。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MainFrame::MainFrame(<span class="keyword">const</span> wxString&amp; title, <span class="keyword">const</span> wxPoint&amp; pos, <span class="keyword">const</span> wxSize&amp; size) </span><br><span class="line">: wxFrame((wxFrame *) <span class="literal">NULL</span>, <span class="number">-1</span>, title, pos, size) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// normally we would initialize objects such as buttons and textboxes here </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，让我们看一下以下初始化代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MainApp::OnInit</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Create an instance of our frame, or window </span></span><br><span class="line">MainFrame *MainWin = <span class="keyword">new</span> MainFrame(_(<span class="string">&quot;Hello World!&quot;</span>), wxDefaultPosition, wxSize(<span class="number">300</span>, <span class="number">200</span>));</span><br><span class="line">MainWin-&gt;Show(<span class="literal">true</span>); <span class="comment">// show the window </span></span><br><span class="line">SetTopWindow(MainWin); <span class="comment">// and finally, set it as the main window </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MainFrame()的第一个参数非常简单，只是框架的标题。 下一个参数是窗口将显示的位置。 我们使用默认位置，但是如果你希望它出现在屏幕上的其他位置，则可以使用wxPoint(int x, int y) 函数。  （例如，要在屏幕的左上角显示它，可以使用wxPoint(0,0)）。第三个参数是我们窗口的大小； 我不会为此烦恼，因为这很容易说明。 创建MainFrame类的实例之后，我们仅显示该窗口并将其设置为主窗口。 不需要最后一步，并且如果不使用它，则将第一帧设置为主窗口，但是最好有。</p><h3 id="2-Adding-A-Button"><a href="#2-Adding-A-Button" class="headerlink" title="2.Adding A Button"></a>2.Adding A Button</h3><p> 当你在Windows或任何多任务操作系统下使用应用程序时，总是单击按钮，使用菜单等。每当你这样做时，都会触发一个事件，并且操作系统会向该程序发送一条消息。 程序初始化时，它会告诉OS如果发生这些事件之一，则需要执行什么操作，并在接收到事件时执行适当的功能。 因此，当你单击按钮时，你的OS会告诉你正在运行的程序，这是发生了什么，该程序告诉OS执行一个功能，然后运行该功能。</p><p>下面代码显示一个带有一个大按钮的窗口，单击该按钮将关闭该窗口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//base.h </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __BASE_H <span class="comment">// Make sure to only declare these classes once</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> __BASE_H</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span>:</span> <span class="keyword">public</span> wxApp <span class="comment">// MainApp is the class for our application</span></span><br><span class="line">    &#123; </span><br><span class="line">    <span class="comment">// MainApp just acts as a container for the window,</span></span><br><span class="line">    <span class="keyword">public</span>: <span class="comment">// or frame in MainFrame</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">OnInit</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MainFrame</span>:</span> <span class="keyword">public</span> wxFrame <span class="comment">// MainFrame is the class for our window,</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// It contains the window and all objects in it</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      MainFrame( <span class="keyword">const</span> wxString &amp;title, <span class="keyword">const</span> wxPoint &amp;pos, <span class="keyword">const</span> wxSize &amp;size );</span><br><span class="line">      wxButton *HelloWorld;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">OnExit</span><span class="params">( wxCommandEvent&amp; event )</span></span>;</span><br><span class="line">  </span><br><span class="line">      DECLARE_EVENT_TABLE()</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      BUTTON_Hello = wxID_HIGHEST + <span class="number">1</span> <span class="comment">// declares an id which will be used to call our button</span></span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//base.c </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wx/wxprec.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifndef</span> WX_PRECOMP</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wx/wx.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;base.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line">  IMPLEMENT_APP(MainApp) <span class="comment">// Initializes the MainApp class and tells our program</span></span><br><span class="line">  <span class="comment">// to run it</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">MainApp::OnInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// Create an instance of our frame, or window</span></span><br><span class="line">    MainFrame *MainWin = <span class="keyword">new</span> MainFrame(_T(<span class="string">&quot;Hello World!&quot;</span>), wxPoint(<span class="number">1</span>, <span class="number">1</span>), wxSize(<span class="number">300</span>,<span class="number">200</span>));</span><br><span class="line">    MainWin-&gt;Show(TRUE); <span class="comment">// show the window</span></span><br><span class="line">    SetTopWindow(MainWin); <span class="comment">// and finally, set it as the main window</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> TRUE;</span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">  BEGIN_EVENT_TABLE ( MainFrame, wxFrame )</span><br><span class="line">    EVT_BUTTON ( BUTTON_Hello, MainFrame::OnExit ) <span class="comment">// Tell the OS to run MainFrame::OnExit when</span></span><br><span class="line">  END_EVENT_TABLE() <span class="comment">// The button is pressed</span></span><br><span class="line"></span><br><span class="line">  MainFrame::MainFrame(<span class="keyword">const</span> wxString &amp;title, <span class="keyword">const</span> wxPoint &amp;pos, <span class="keyword">const</span> wxSize</span><br><span class="line">    &amp;size): wxFrame((wxFrame*)<span class="literal">NULL</span>,  - <span class="number">1</span>, title, pos, size)</span><br><span class="line">  &#123;</span><br><span class="line">    HelloWorld = <span class="keyword">new</span> wxButton(<span class="keyword">this</span>, BUTTON_Hello, _T(<span class="string">&quot;Hello World&quot;</span>),</span><br><span class="line">      <span class="comment">// shows a button on this window</span></span><br><span class="line">    wxDefaultPosition, wxDefaultSize, <span class="number">0</span>); <span class="comment">// with the text &quot;hello World&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MainFrame::OnExit</span><span class="params">( wxCommandEvent&amp; event )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Close(TRUE); <span class="comment">// Tells the OS to quit running this process</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/pictures/wxWidgets/02/2.png" alt="运行结果"></p><p>这段代码声明了我们的按钮将使用的ID，将其设置为wxID_HIGHEST + 1，以避免它与wxWindows已经声明的默认ID之一相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  BUTTON_Hello = wxID_HIGHEST + <span class="number">1</span> <span class="comment">// declares an id which will be used to call our button</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码定义了当持有BUTTON_Hello ID的按钮发生EVT_BUTTON类型的事件或单击按钮时，应执行函数MainFrame :: OnExit。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN_EVENT_TABLE ( MainFrame, wxFrame )</span><br><span class="line">EVT_BUTTON ( BUTTON_Hello, MainFrame::OnExit ) <span class="comment">// Tell the OS to run MainFrame::OnExit when</span></span><br><span class="line">END_EVENT_TABLE() <span class="comment">// The button is pressed</span></span><br></pre></td></tr></table></figure><p>这段代码添加了一个按钮，其parent设置为“ this”（或MainFrame），以便它显示在此框架上，其ID设置为BUTTON_Hello，我们已在前面声明了它，一些默认值，标签设置为“ Hello World”  ，最后一个参数是默认样式。最后一个参数也可以是几种不同的样式。 以下是一些（来自手册）：</p><ul><li>wxBU_LEFT: 将标签左对齐。 仅限于WIN32。</li><li>wxBU_TOP :将标签对准按钮的顶部。 仅限于WIN32。</li><li>wxBU_RIGHT: 右对齐位图标签。 仅限于WIN32。</li><li>wxBU_BOTTOM: 将标签对准按钮的底部。 仅限于WIN32。</li><li>wxBU_EXACTFIT: 创建尽可能小的按钮，而不是使其达到标准大小（这是默认行为）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HelloWorld = <span class="keyword">new</span> wxButton(<span class="keyword">this</span>, BUTTON_Hello, _T(<span class="string">&quot;Hello World&quot;</span>), <span class="comment">// shows a button on this window</span></span><br><span class="line">wxDefaultPosition, wxDefaultSize, <span class="number">0</span>);                   <span class="comment">// with the text &quot;hello World&quot;</span></span><br></pre></td></tr></table></figure><p>最后的代码很简单，我们告诉wxWindows在单击按钮时运行的函数。 我们只是运行Close（）命令来退出程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainFrame::OnExit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Close(TRUE); <span class="comment">// Tells the OS to quit running this process</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Using-The-WxTextCtrl"><a href="#3-Using-The-WxTextCtrl" class="headerlink" title="3.Using The WxTextCtrl"></a>3.Using The WxTextCtrl</h3><p>首先，让我们添加一个状态栏！ 这并不像听起来那样难，实际上可以用一行简单的代码来完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MainFrame::MainFrame(<span class="keyword">const</span> wxString &amp;title, <span class="keyword">const</span> wxPoint &amp;pos, <span class="keyword">const</span> wxSize &amp;size) \</span><br><span class="line">                     : wxFrame((wxFrame *) <span class="literal">NULL</span>, <span class="number">-1</span>, title, pos, size)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">CreateStatusBar(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个也是唯一的参数是状态栏可以包含多少部分。 如果您只想一次在状态栏中显示一条消息，请将其设置为“ 1”；如果您希望更多，则将其设置为另一条数字。 现在，让我们用一个漂亮的文本框替换这个难看的按钮。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//base.h </span></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MainFrame</span>:</span> <span class="keyword">public</span> wxFrame <span class="comment">// MainFrame is the class for our window,</span></span><br><span class="line">  &#123; <span class="comment">// It contains the window and all objects in it</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">  </span><br><span class="line">    MainFrame( <span class="keyword">const</span> wxString &amp;title, <span class="keyword">const</span> wxPoint &amp;pos, <span class="keyword">const</span> wxSize &amp;size );</span><br><span class="line">    wxTextCtrl *MainEditBox;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//base.c</span></span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  MainFrame::MainFrame(<span class="keyword">const</span> wxString &amp;title, <span class="keyword">const</span> wxPoint &amp;pos, <span class="keyword">const</span> wxSize &amp;size)</span><br><span class="line">  : wxFrame((wxFrame *) <span class="literal">NULL</span>, <span class="number">-1</span>, title, pos, size)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">// Initialize our text box with an id of TEXT_Main, and the label &quot;hi&quot;</span></span><br><span class="line">  MainEditBox = <span class="keyword">new</span> wxTextCtrl(<span class="keyword">this</span>, TEXT_Main, <span class="string">&quot;Hi!&quot;</span>, wxDefaultPosition, wxDefaultSize,  </span><br><span class="line">    wxTE_MULTILINE | wxTE_RICH , wxDefaultValidator, wxTextCtrlNameStr);</span><br><span class="line">  </span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>wxTextCtrl类具有许多有用的功能，但我们仅介绍三个。 这三个是：LoadFile（“ filename.txt”），SaveFile（“ filename.txt”）和Clear（）。 您应该能够猜到LoadFile（）将给定文件名的内容加载到文本控件中，SaveFile（）将文本框的内容保存为给定文件名，而Clear（）清除文本控件的内容。</p><p>现在添加菜单栏。 将菜单栏添加到当前框架并不难，并且菜单项的事件与我们在上一课中创建的按钮的事件相同。 首先，我们包含，并使用以下内容创建菜单栏的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MainMenu = <span class="keyword">new</span> wxMenuBar();</span><br></pre></td></tr></table></figure><p>现在我们需要一个菜单，从传统的文件菜单开始：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wxMenu *FileMenu = <span class="keyword">new</span> wxMenu();</span><br></pre></td></tr></table></figure><p>现在我们已经声明了一个菜单和菜单栏，让我们向其中添加一些项目。 我们可以通过输入以下内容添加一个退出选项（使用MENU_Quit的ID）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileMenu-&gt;Append(MENU_Quit, <span class="string">&quot;&amp;Quit&quot;</span>, <span class="string">&quot;Quit the editor&quot;</span>);</span><br><span class="line"><span class="comment">/* Adds a menu item with the label &quot;Quit&quot;, id of MENU_Quit, and set the status bar caption to </span></span><br><span class="line"><span class="comment">&quot;Quit the editor&quot; when the mouse hovers over it.</span></span><br><span class="line"><span class="comment">We can also use FileMenu-&gt;AppendSeparator() to add a menu separator */</span></span><br></pre></td></tr></table></figure><p>现在，我们只需将“文件”菜单附加到我们的菜单栏，并告诉框架“ MainMenu”应为其菜单栏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MainMenu-&gt;Append(FileMenu, <span class="string">&quot;&amp;File&quot;</span>);</span><br><span class="line">SetMenuBar(MainMenu);</span><br></pre></td></tr></table></figure><p>现在，如果我们使用下面的源代码，我们将得到一个看起来像这样的应用程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//base.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __BASE_H <span class="comment">// Make sure to only declare these classes once</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> __BASE_H</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wx/frame.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wx/textctrl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span>:</span> <span class="keyword">public</span> wxApp <span class="comment">// MainApp is the class for our application</span></span><br><span class="line">  &#123; <span class="comment">// MainApp just acts as a container for the window,</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="comment">// or frame in MainFrame</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">OnInit</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MainFrame</span>:</span> <span class="keyword">public</span> wxFrame <span class="comment">// MainFrame is the class for our window,</span></span><br><span class="line">  &#123; <span class="comment">// It contains the window and all objects in it</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    MainFrame( <span class="keyword">const</span> wxString&amp; title, <span class="keyword">const</span> wxPoint&amp; pos, <span class="keyword">const</span> wxSize&amp; size );</span><br><span class="line">    wxTextCtrl *MainEditBox;</span><br><span class="line">    wxMenuBar *MainMenu;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Quit</span><span class="params">(wxCommandEvent&amp; event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NewFile</span><span class="params">(wxCommandEvent&amp; event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OpenFile</span><span class="params">(wxCommandEvent&amp; event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SaveFile</span><span class="params">(wxCommandEvent&amp; event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SaveFileAs</span><span class="params">(wxCommandEvent&amp; event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloseFile</span><span class="params">(wxCommandEvent&amp; event)</span></span>;</span><br><span class="line"></span><br><span class="line">    DECLARE_EVENT_TABLE()</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    TEXT_Main = wxID_HIGHEST + <span class="number">1</span>, <span class="comment">// declares an id which will be used to call our button</span></span><br><span class="line">    MENU_New,</span><br><span class="line">    MENU_Open,</span><br><span class="line">    MENU_Close,</span><br><span class="line">    MENU_Save,</span><br><span class="line">    MENU_SaveAs,</span><br><span class="line">    MENU_Quit</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//base.c  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wx/wxprec.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifndef</span> WX_PRECOMP</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wx/wx.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;base.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">  BEGIN_EVENT_TABLE ( MainFrame, wxFrame )</span><br><span class="line">  EVT_MENU(MENU_New, MainFrame::NewFile)</span><br><span class="line">  EVT_MENU(MENU_Open, MainFrame::OpenFile)</span><br><span class="line">  EVT_MENU(MENU_Close, MainFrame::CloseFile)</span><br><span class="line">  EVT_MENU(MENU_Save, MainFrame::SaveFile)</span><br><span class="line">  EVT_MENU(MENU_SaveAs, MainFrame::SaveFileAs)</span><br><span class="line">  EVT_MENU(MENU_Quit, MainFrame::Quit)</span><br><span class="line">  END_EVENT_TABLE()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  IMPLEMENT_APP(MainApp) <span class="comment">// Initializes the MainApp class and tells our program</span></span><br><span class="line">  <span class="comment">// to run it</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">MainApp::OnInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    MainFrame *MainWin = <span class="keyword">new</span> MainFrame(wxT(<span class="string">&quot;Hello World!&quot;</span>), wxPoint(<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">    wxSize(<span class="number">300</span>, <span class="number">200</span>)); <span class="comment">// Create an instance of our frame, or window</span></span><br><span class="line">    MainWin-&gt;Show(TRUE); <span class="comment">// show the window</span></span><br><span class="line">    SetTopWindow(MainWin);<span class="comment">// and finally, set it as the main window</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MainFrame::MainFrame(<span class="keyword">const</span> wxString&amp; title,</span><br><span class="line">    <span class="keyword">const</span> wxPoint&amp; pos, <span class="keyword">const</span> wxSize&amp; size)</span><br><span class="line">      : wxFrame((wxFrame *) <span class="literal">NULL</span>, <span class="number">-1</span>, title, pos, size)</span><br><span class="line">  &#123;</span><br><span class="line">    CreateStatusBar(<span class="number">2</span>);</span><br><span class="line">    MainMenu = <span class="keyword">new</span> wxMenuBar();</span><br><span class="line">    wxMenu *FileMenu = <span class="keyword">new</span> wxMenu();</span><br><span class="line"></span><br><span class="line">    FileMenu-&gt;Append(MENU_New, wxT(<span class="string">&quot;&amp;New&quot;</span>),</span><br><span class="line">      wxT(<span class="string">&quot;Create a new file&quot;</span>));</span><br><span class="line">    FileMenu-&gt;Append(MENU_Open, wxT(<span class="string">&quot;&amp;Open&quot;</span>),</span><br><span class="line">      wxT(<span class="string">&quot;Open an existing file&quot;</span>));</span><br><span class="line">    FileMenu-&gt;Append(MENU_Close, wxT(<span class="string">&quot;&amp;Close&quot;</span>),</span><br><span class="line">      wxT(<span class="string">&quot;Close the current document&quot;</span>));</span><br><span class="line">    FileMenu-&gt;Append(MENU_Save, wxT(<span class="string">&quot;&amp;Save&quot;</span>),</span><br><span class="line">      wxT(<span class="string">&quot;Save the current document&quot;</span>));</span><br><span class="line">    FileMenu-&gt;Append(MENU_SaveAs, wxT(<span class="string">&quot;Save &amp;As&quot;</span>),</span><br><span class="line">      wxT(<span class="string">&quot;Save the current document under a new file name&quot;</span>));</span><br><span class="line">    FileMenu-&gt;Append(MENU_Quit, wxT(<span class="string">&quot;&amp;Quit&quot;</span>),</span><br><span class="line">      wxT(<span class="string">&quot;Quit the editor&quot;</span>));</span><br><span class="line"></span><br><span class="line">    MainMenu-&gt;Append(FileMenu, wxT(<span class="string">&quot;File&quot;</span>));</span><br><span class="line">    SetMenuBar(MainMenu);</span><br><span class="line"></span><br><span class="line">    MainEditBox = <span class="keyword">new</span> wxTextCtrl(<span class="keyword">this</span>, TEXT_Main,</span><br><span class="line">      wxT(<span class="string">&quot;Hi!&quot;</span>), wxDefaultPosition, wxDefaultSize,</span><br><span class="line">      wxTE_MULTILINE | wxTE_RICH , wxDefaultValidator, wxTextCtrlNameStr);</span><br><span class="line">      Maximize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MainFrame::NewFile</span><span class="params">(wxCommandEvent&amp; WXUNUSED(event))</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MainFrame::OpenFile</span><span class="params">(wxCommandEvent&amp; WXUNUSED(event))</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    MainEditBox-&gt;LoadFile(wxT(<span class="string">&quot;base.h&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MainFrame::CloseFile</span><span class="params">(wxCommandEvent&amp; WXUNUSED(event))</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    MainEditBox-&gt;Clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MainFrame::SaveFile</span><span class="params">(wxCommandEvent&amp; WXUNUSED(event))</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    MainEditBox-&gt;SaveFile(wxT(<span class="string">&quot;base.h&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MainFrame::SaveFileAs</span><span class="params">(wxCommandEvent&amp; WXUNUSED(event))</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MainFrame::Quit</span><span class="params">(wxCommandEvent&amp; WXUNUSED(event))</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Close(TRUE); <span class="comment">// Tells the OS to quit running this process</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/pictures/wxWidgets/02/3.png" alt="运行结果"></p><h3 id="4-Common-Dialogs"><a href="#4-Common-Dialogs" class="headerlink" title="4.Common Dialogs"></a>4.Common Dialogs</h3><p>除了创建自己的对话框窗口外，在wxWidgets中还可以轻松使用所谓的“通用对话框”。 常用对话框是用于各种操作的预制对话框。 优点是创建对话框所需的工作较少，并且对话框继承了运行应用程序的操作系统的外观。 这是创建可移植应用程序的一大优势。</p><p>从简单的消息框到用户输入框，再到完整的文件选择对话框，都有常见的对话框。 我们在这里介绍了用于打开和保存文件的文件选择对话框。 如果您想查看其他可用的内容，则手册中有一些很好的信息。</p><p>初始化文件选择对话框并不难-我们只需声明一个新的wxFileDialog对象并使用以下参数对其进行初始化：</p><p>1.父窗口；</p><p>2.对话窗口的标题；</p><p>3.默认目录；</p><p>4.默认文件名；</p><p>5.我们将使用以下格式的文件类型的通配符：<code>&quot;File type (*.ext)|*.ext|&quot;</code></p><p>6.对话框样式。wxFD_OPEN：打开文件；wxFD_MULTIPLE：允许选择多个文件； wxFD_SAVE：保存文件；wxFD_OVERWRITE_PROMPT：提示用户是否尝试覆盖文件进行确认。</p><p>当我们要获取用户选择的文件的数据时，我们首先检查wxFileDialog-&gt; ShowModal（）是否返回wxID_OK（意味着用户按下了“确定”按钮）。 然后，我们使用GetDirectory返回文件所在的目录，使用GetFilename返回不带目录的文件名，如果在创建对话框时设置wxMULTIPLE则使用GetFilenames，并使用GetPath返回所选文件的完整路径。 以下是改进的OpenFile（）函数的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainFrame::OpenFile</span><span class="params">(wxCommandEvent&amp; WXUNUSED(event))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">wxFileDialog* OpenDialog = <span class="keyword">new</span> wxFileDialog(</span><br><span class="line"><span class="keyword">this</span>, _(<span class="string">&quot;Choose a file to open&quot;</span>), wxEmptyString, wxEmptyString, </span><br><span class="line">_(<span class="string">&quot;Text files (*.txt)|*.txt|C++ Source Files (*.cpp, *.cxx)|*.cpp;*.cxx|C Source files (*.c)|*.c|C header files (*.h)|*.h&quot;</span>),</span><br><span class="line">wxFD_OPEN, wxDefaultPosition);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a &quot;open file&quot; dialog with 4 file types</span></span><br><span class="line"><span class="keyword">if</span> (OpenDialog-&gt;ShowModal() == wxID_OK) <span class="comment">// if the user click &quot;Open&quot; instead of &quot;Cancel&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">CurrentDocPath = OpenDialog-&gt;GetPath();</span><br><span class="line"><span class="comment">// Sets our current document to the file the user selected</span></span><br><span class="line">MainEditBox-&gt;LoadFile(CurrentDocPath); <span class="comment">//Opens that file</span></span><br><span class="line">SetTitle(wxString(<span class="string">&quot;Edit - &quot;</span>) &lt;&lt; </span><br><span class="line">OpenDialog-&gt;GetFilename()); <span class="comment">// Set the Title to reflect the file open</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clean up after ourselves</span></span><br><span class="line">OpenDialog-&gt;Destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是创建此代码的来源：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//base.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wx/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wx/menu.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wx/textctrl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MainApp is the class for our application, it just acts</span></span><br><span class="line"><span class="comment">// as a container for the window or frame in MainFrame.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainApp</span>:</span> <span class="keyword">public</span> wxApp</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">OnInit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MainFrame is the class for our window, it</span></span><br><span class="line"><span class="comment">// contains the window and all objects in it.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainFrame</span>:</span> <span class="keyword">public</span> wxFrame</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MainFrame( <span class="keyword">const</span> wxString &amp;title, <span class="keyword">const</span> wxPoint &amp;pos, <span class="keyword">const</span> wxSize &amp;size );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quit</span><span class="params">( wxCommandEvent&amp; event )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NewFile</span><span class="params">( wxCommandEvent&amp; event )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OpenFile</span><span class="params">( wxCommandEvent&amp; event )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SaveFile</span><span class="params">( wxCommandEvent&amp; event )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SaveFileAs</span><span class="params">( wxCommandEvent&amp; event )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CloseFile</span><span class="params">( wxCommandEvent&amp; event )</span></span>;</span><br><span class="line"></span><br><span class="line">wxTextCtrl *MainEditBox;</span><br><span class="line">wxMenuBar *MainMenu;</span><br><span class="line"><span class="comment">// The Path to the file we have open</span></span><br><span class="line">wxString CurrentDocPath;</span><br><span class="line"></span><br><span class="line">DECLARE_EVENT_TABLE()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// declares an id which will be used to call our button</span></span><br><span class="line">TEXT_Main = wxID_HIGHEST + <span class="number">1</span>,</span><br><span class="line">MENU_New,</span><br><span class="line">MENU_Open,</span><br><span class="line">MENU_Close,</span><br><span class="line">MENU_Save,</span><br><span class="line">MENU_SaveAs,</span><br><span class="line">MENU_Quit</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BEGIN_EVENT_TABLE ( MainFrame, wxFrame )</span><br><span class="line">EVT_MENU(MENU_New, MainFrame::NewFile)</span><br><span class="line">EVT_MENU(MENU_Open, MainFrame::OpenFile) </span><br><span class="line">EVT_MENU(MENU_Close, MainFrame::CloseFile)</span><br><span class="line">EVT_MENU(MENU_Save, MainFrame::SaveFile)</span><br><span class="line">EVT_MENU(MENU_SaveAs, MainFrame::SaveFileAs)</span><br><span class="line">EVT_MENU(MENU_Quit, MainFrame::Quit)</span><br><span class="line">END_EVENT_TABLE()</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//base.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wx/wxprec.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WX_PRECOMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wx/wx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;base.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">IMPLEMENT_APP(MainApp) <span class="comment">// Initializes the MainApp class...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .. and tells our program to run it</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MainApp::OnInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Create an instance of our frame, or window</span></span><br><span class="line">MainFrame *MainWin = <span class="keyword">new</span> MainFrame(</span><br><span class="line">_(<span class="string">&quot;Edit&quot;</span>), wxPoint(<span class="number">1</span>, <span class="number">1</span>), wxSize(<span class="number">300</span>, <span class="number">200</span>));</span><br><span class="line">MainWin-&gt;Show(TRUE); <span class="comment">// show the window</span></span><br><span class="line">SetTopWindow(MainWin); <span class="comment">// and finally, set it as the main window</span></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainFrame::MainFrame(<span class="keyword">const</span> wxString &amp;title, <span class="keyword">const</span> wxPoint &amp;pos, <span class="keyword">const</span> wxSize &amp;size)</span><br><span class="line">: wxFrame((wxFrame*) <span class="literal">NULL</span>, <span class="number">-1</span>, title, pos, size)</span><br><span class="line">&#123;</span><br><span class="line">CreateStatusBar(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">MainMenu = <span class="keyword">new</span> wxMenuBar();</span><br><span class="line">wxMenu *FileMenu = <span class="keyword">new</span> wxMenu();</span><br><span class="line"></span><br><span class="line">FileMenu-&gt;Append(MENU_New,</span><br><span class="line">_(<span class="string">&quot;&amp;New&quot;</span>), _(<span class="string">&quot;Create a new file&quot;</span>));</span><br><span class="line"></span><br><span class="line">FileMenu-&gt;AppendSeparator();</span><br><span class="line">FileMenu-&gt;Append(MENU_Open,</span><br><span class="line">_(<span class="string">&quot;&amp;Open&quot;</span>), _(<span class="string">&quot;Open an existing file&quot;</span>));</span><br><span class="line">FileMenu-&gt;Append(MENU_Close,</span><br><span class="line">_(<span class="string">&quot;&amp;Close&quot;</span>), _(<span class="string">&quot;Close the current document&quot;</span>));</span><br><span class="line"></span><br><span class="line">FileMenu-&gt;AppendSeparator();</span><br><span class="line">FileMenu-&gt;Append(MENU_Save,</span><br><span class="line">_(<span class="string">&quot;&amp;Save&quot;</span>), _(<span class="string">&quot;Save the current document&quot;</span>));</span><br><span class="line">FileMenu-&gt;Append(MENU_SaveAs,</span><br><span class="line">_(<span class="string">&quot;Save &amp;As&quot;</span>), _(<span class="string">&quot;Save the current document under a new file  name&quot;</span>));</span><br><span class="line"></span><br><span class="line">FileMenu-&gt;AppendSeparator();</span><br><span class="line">FileMenu-&gt;Append(MENU_Quit,</span><br><span class="line">_(<span class="string">&quot;&amp;Quit&quot;</span>), _(<span class="string">&quot;Quit the editor&quot;</span>));</span><br><span class="line"></span><br><span class="line">MainMenu-&gt;Append(FileMenu, _(<span class="string">&quot;&amp;File&quot;</span>));</span><br><span class="line">SetMenuBar(MainMenu);</span><br><span class="line"></span><br><span class="line">MainEditBox = <span class="keyword">new</span> wxTextCtrl(</span><br><span class="line"><span class="keyword">this</span>, TEXT_Main, _(<span class="string">&quot;Hi!&quot;</span>), wxDefaultPosition, wxDefaultSize, </span><br><span class="line">wxTE_MULTILINE | wxTE_RICH , wxDefaultValidator, wxTextCtrlNameStr);</span><br><span class="line"></span><br><span class="line">Maximize(); <span class="comment">// Maximize the window</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainFrame::NewFile</span><span class="params">(wxCommandEvent&amp; WXUNUSED(event))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Clear the edit box</span></span><br><span class="line">MainEditBox-&gt;Clear();</span><br><span class="line"><span class="comment">// reset the path of our current open file</span></span><br><span class="line">CurrentDocPath = wxT(<span class="string">&quot;C:/&quot;</span>);</span><br><span class="line"><span class="comment">// Set the Title to reflect the file open</span></span><br><span class="line">SetTitle(_(<span class="string">&quot;Edit - untitled *&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainFrame::OpenFile</span><span class="params">(wxCommandEvent&amp; WXUNUSED(event))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">wxFileDialog *OpenDialog = <span class="keyword">new</span> wxFileDialog(</span><br><span class="line"><span class="keyword">this</span>, _(<span class="string">&quot;Choose a file to open&quot;</span>), wxEmptyString, wxEmptyString,</span><br><span class="line">_(<span class="string">&quot;Text files (*.txt)|*.txt|C++ Source Files (*.cpp, *.cxx)|*.cpp;*.cxx|C Source files (*.c)|*.c|C header files (*.h)|*.h&quot;</span>),</span><br><span class="line">wxFD_OPEN, wxDefaultPosition);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a &quot;open file&quot; dialog with 4 file types</span></span><br><span class="line"><span class="keyword">if</span> (OpenDialog-&gt;ShowModal() == wxID_OK) <span class="comment">// if the user click &quot;Open&quot; instead of &quot;cancel&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">CurrentDocPath = OpenDialog-&gt;GetPath();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets our current document to the file the user selected</span></span><br><span class="line">MainEditBox-&gt;LoadFile(CurrentDocPath); <span class="comment">//Opens that file</span></span><br><span class="line"><span class="comment">// Set the Title to reflect the  file open</span></span><br><span class="line">SetTitle(wxString(<span class="string">&quot;Edit - &quot;</span>) &lt;&lt; OpenDialog-&gt;GetFilename());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainFrame::CloseFile</span><span class="params">(wxCommandEvent&amp; WXUNUSED(event))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Clear the Text Box</span></span><br><span class="line">MainEditBox-&gt;Clear();</span><br><span class="line"><span class="comment">// Reset the current File being edited</span></span><br><span class="line">CurrentDocPath = wxT(<span class="string">&quot;C:/&quot;</span>);</span><br><span class="line"><span class="comment">// Set the Title to reflect the file open</span></span><br><span class="line">SetTitle(_(<span class="string">&quot;Edit - untitled *&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainFrame::SaveFile</span><span class="params">(wxCommandEvent&amp; WXUNUSED(event))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Save to the already-set path for the document</span></span><br><span class="line">MainEditBox-&gt;SaveFile(CurrentDocPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainFrame::SaveFileAs</span><span class="params">(wxCommandEvent&amp; WXUNUSED(event))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">wxFileDialog *SaveDialog = <span class="keyword">new</span> wxFileDialog(</span><br><span class="line"><span class="keyword">this</span>, _(<span class="string">&quot;Save File As _?&quot;</span>), wxEmptyString, wxEmptyString,</span><br><span class="line">_(<span class="string">&quot;Text files (*.txt)|*.txt|C++ Source Files (*.cpp)|*.cpp|C Source files (*.c)|*.c|C header files (*.h)|*.h&quot;</span>),</span><br><span class="line">wxFD_SAVE | wxFD_OVERWRITE_PROMPT, wxDefaultPosition);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a Save Dialog with 4 file types</span></span><br><span class="line"><span class="keyword">if</span> (SaveDialog-&gt;ShowModal() == wxID_OK) <span class="comment">// If the user clicked &quot;OK&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">CurrentDocPath = SaveDialog-&gt;GetPath();</span><br><span class="line"><span class="comment">// set the path of our current document to the file the user chose to save under</span></span><br><span class="line">MainEditBox-&gt;SaveFile(CurrentDocPath); <span class="comment">// Save the file to the selected path</span></span><br><span class="line"><span class="comment">// Set the Title to reflect the file open</span></span><br><span class="line">SetTitle(wxString(<span class="string">&quot;Edit - &quot;</span>) &lt;&lt; SaveDialog-&gt;GetFilename());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clean up after ourselves</span></span><br><span class="line">SaveDialog-&gt;Destroy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainFrame::Quit</span><span class="params">(wxCommandEvent&amp; WXUNUSED(event))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Close(TRUE); <span class="comment">// Close the window</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> wxWidgets </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wxWidgets </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Ray Tracing in a Weekend》学习笔记07</title>
      <link href="2020/11/14/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B007/"/>
      <url>2020/11/14/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B007/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-EirPrQov" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="30814948" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#3F51B5"    ></div><p><strong>10. Dielectrics</strong></p><p>透明材料（例如水，玻璃和钻石）是电介质。 当光线射到它们上时，它分裂为反射射线和折射（透射）射线。 我们将通过在反射或折射之间随机选择，并且每次交互仅生成一条散射射线来解决这一问题。</p><h5 id="10-1-Refraction"><a href="#10-1-Refraction" class="headerlink" title="10.1 Refraction"></a><strong>10.1 Refraction</strong></h5><p>最难调试的部分是折射射线。 如果有折射光线，我通常通常首先将所有光线折射。</p><h5 id="10-2-Snell’s-Law"><a href="#10-2-Snell’s-Law" class="headerlink" title="10.2 Snell’s Law"></a>10.2 Snell’s Law</h5><p>Snell折射定律描述了折射：<br>$$<br>\eta \cdot \sin\theta = \eta’ \cdot \sin\theta’<br>$$<br>其中θ和θ’是与法线的夹角，而η和η’是折射率（通常空气= 1.0，玻璃= 1.3-1.7，钻石= 2.4）。 几何形状为：</p><img src="/pictures/RayTracing/07/1.png" alt="Ray refraction" style="zoom:50%;" /><p>为了确定折射射线的方向，我们必须求解sinθ’：<br>$$<br>\sin\theta’ = \frac{\eta}{\eta’} \cdot \sin\theta<br>$$<br>在表面的折射侧上，存在折射光线R’和法线n’，并且它们之间存在角度θ’。 我们可以将R’分为垂直于n’且平行于n’的射线部分：</p><p><img src="/pictures/RayTracing/07/6.png" alt="公式"></p><p>求解R’⊥和R’∥的证明步骤：</p><p><img src="/pictures/RayTracing/07/2.png" alt="证明步骤"></p><p>我们仍然需要求解cosθ。 众所周知，两个向量的点积可以用它们之间的角度的余弦来解释：<br>$$<br>\mathbf{a} \cdot \mathbf{b} = |\mathbf{a}| |\mathbf{b}| \cos\theta<br>$$<br>如果将a和b限制为单位向量：<br>$$<br>a⋅b=cosθ<br>$$<br>现在我们可以用已知量重写R’⊥：<br>$$<br>\mathbf{R’}_{\bot} =<br>     \frac{\eta}{\eta’} (\mathbf{R} + (\mathbf{-R} \cdot \mathbf{n}) \mathbf{n})<br>$$<br>当我们将它们重新组合在一起时，我们可以编写一个函数来计算R’：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[vec3.h] Refraction function</span></span><br><span class="line"><span class="function">vec3 <span class="title">refract</span><span class="params">(<span class="keyword">const</span> vec3&amp; uv, <span class="keyword">const</span> vec3&amp; n, <span class="keyword">double</span> etai_over_etat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cos_theta = dot(-uv, n);<span class="comment">//uv就是入射向量，n是表面法向量</span></span><br><span class="line">    vec3 r_out_perp =  etai_over_etat * (uv + cos_theta*n);</span><br><span class="line">    vec3 r_out_parallel = -<span class="built_in">sqrt</span>(<span class="built_in">fabs</span>(<span class="number">1.0</span> - r_out_perp.length_squared())) * n;</span><br><span class="line">    <span class="keyword">return</span> r_out_perp + r_out_parallel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总是折射的介质材料是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[material.h] Dielectric material class that always refracts</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dielectric</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        dielectric(<span class="keyword">double</span> index_of_refraction) : ir(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            attenuation = color(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">            <span class="keyword">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span>/ir) : ir;</span><br><span class="line"></span><br><span class="line">            vec3 unit_direction = unit_vector(r_in.direction());</span><br><span class="line">            vec3 refracted = refract(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line"></span><br><span class="line">            scattered = ray(rec.p, refracted);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">double</span> ir; <span class="comment">// Index of Refraction</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，我们将更新场景以将左侧和中央球体更改为玻璃：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[main.c] Changing left and center spheres to glass</span></span><br><span class="line"><span class="keyword">auto</span> material_ground = make_shared&lt;lambertian&gt;(color(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line"><span class="keyword">auto</span> material_center = make_shared&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">auto</span> material_left   = make_shared&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">auto</span> material_right  = make_shared&lt;metal&gt;(color(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p><img src="/pictures/RayTracing/07/3.png" alt="Glass sphere that always refracts"></p><h5 id="10-3-Total-Internal-Reflection"><a href="#10-3-Total-Internal-Reflection" class="headerlink" title="10.3 Total Internal Reflection"></a>10.3 Total Internal Reflection</h5><p>一个棘手的实际问题是，当光线处于折射率较高的材料中时，无法真正解决Snell定律，因此就不可能发生折射。 如果回头看Snell定律和sinθ′的推导：<br>$$<br>\sin\theta’ = \frac{\eta}{\eta’} \cdot \sin\theta<br>$$<br>如果射线是在玻璃内部而外部是空气（η= 1.5和η’= 1.0）：<br>$$<br>\sin\theta’ = \frac{1.5}{1.0} \cdot \sin\theta<br>$$<br>等式两侧的等式被破坏，并且不存在解。 如果不存在溶液，则玻璃不能折射，因此必须反射射线：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[material.h] Determining if the ray can refract</span></span><br><span class="line"><span class="keyword">if</span> (refraction_ratio * sin_theta &gt; <span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="comment">// Must Reflect</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Can Refract</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，所有的光都被反射，并且由于实际上通常是在固体物体内部，因此被称为“全内反射”。 这就是为什么当您被淹没时，有时水-空气边界会充当完美的镜子的原因。</p><p>我们可以使用三角性质来求解<code>sin_theta</code>：<br>$$<br>\sin\theta  = \sqrt{1 - \cos^2\theta}<br>$$</p><p>$$<br>\cos\theta = \mathbf{R} \cdot \mathbf{n}<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[material.h] Determining if the ray can refract</span></span><br><span class="line"><span class="keyword">double</span> cos_theta = fmin(dot(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta*cos_theta);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (refraction_ratio * sin_theta &gt; <span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="comment">// Must Reflect</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Can Refract</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总是折射（如果可能）的介质材料是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[material.h] Dielectric material class with reflection</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dielectric</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        dielectric(<span class="keyword">double</span> index_of_refraction) : ir(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            attenuation = color(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">            <span class="comment">//区别正反面</span></span><br><span class="line">            <span class="keyword">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span>/ir) : ir;</span><br><span class="line"></span><br><span class="line">            vec3 unit_direction = unit_vector(r_in.direction());</span><br><span class="line">            <span class="keyword">double</span> cos_theta = fmin(dot(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">            <span class="keyword">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta*cos_theta);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> cannot_refract = refraction_ratio * sin_theta &gt; <span class="number">1.0</span>;</span><br><span class="line">            vec3 direction;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cannot_refract) &#123;</span><br><span class="line">                direction = reflect(unit_direction, rec.normal);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                direction = refract(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line"></span><br><span class="line">            scattered = ray(rec.p, direction);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">double</span> ir; <span class="comment">// Index of Refraction</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Attenuation始终为1-玻璃表面不吸收任何东西。 如果我们使用以下参数进行尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[main.c] Scene with dielectric and shiny sphere</span></span><br><span class="line"><span class="keyword">auto</span> material_ground = make_shared&lt;lambertian&gt;(color(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line"><span class="keyword">auto</span> material_center = make_shared&lt;lambertian&gt;(color(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>));</span><br><span class="line"><span class="keyword">auto</span> material_left   = make_shared&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">auto</span> material_right  = make_shared&lt;metal&gt;(color(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">0.0</span>);</span><br></pre></td></tr></table></figure><p><img src="/pictures/RayTracing/07/4.png" alt="Glass sphere that sometimes refracts"></p><h5 id="10-4-Schlick-Approximation"><a href="#10-4-Schlick-Approximation" class="headerlink" title="10.4 Schlick Approximation"></a>10.4 Schlick Approximation</h5><p>现在，真正的玻璃具有随角度变化的反射率-以陡峭的角度看着窗户，它变成一面镜子。 这样做有一个丑陋的方程，但是几乎每个人都使用Christophe Schlick的廉价且令人惊讶的精确多项式近似。 这产生了我们完整的玻璃材料：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[material.h] Full glass material</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dielectric</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        dielectric(<span class="keyword">double</span> index_of_refraction) : ir(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            attenuation = color(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">            <span class="keyword">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span>/ir) : ir;</span><br><span class="line"></span><br><span class="line">            vec3 unit_direction = unit_vector(r_in.direction());</span><br><span class="line">            <span class="keyword">double</span> cos_theta = fmin(dot(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">            <span class="keyword">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta*cos_theta);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> cannot_refract = refraction_ratio * sin_theta &gt; <span class="number">1.0</span>;</span><br><span class="line">            vec3 direction;</span><br><span class="line">            <span class="keyword">if</span> (cannot_refract || reflectance(cos_theta, refraction_ratio) &gt; random_double())</span><br><span class="line">                direction = reflect(unit_direction, rec.normal);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                direction = refract(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line"></span><br><span class="line">            scattered = ray(rec.p, direction);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">double</span> ir; <span class="comment">// Index of Refraction</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">reflectance</span><span class="params">(<span class="keyword">double</span> cosine, <span class="keyword">double</span> ref_idx)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Use Schlick&#x27;s approximation for reflectance.</span></span><br><span class="line">            <span class="keyword">auto</span> r0 = (<span class="number">1</span>-ref_idx) / (<span class="number">1</span>+ref_idx);</span><br><span class="line">            r0 = r0*r0;</span><br><span class="line">            <span class="keyword">return</span> r0 + (<span class="number">1</span>-r0)*<span class="built_in">pow</span>((<span class="number">1</span> - cosine),<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="10-5-Modeling-a-Hollow-Glass-Sphere"><a href="#10-5-Modeling-a-Hollow-Glass-Sphere" class="headerlink" title="10.5 Modeling a Hollow Glass Sphere"></a>10.5 Modeling a Hollow Glass Sphere</h5><p>使用电介质球体一个有趣且简单的技巧是注意，如果您使用负半径，则几何形状不会受到影响，但表面法线指向内部。 可以将其用作制造空心玻璃球的气泡：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[main.cc] Scene with hollow glass sphere</span></span><br><span class="line">world.add(make_shared&lt;sphere&gt;(point3( <span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">world.add(make_shared&lt;sphere&gt;(point3( <span class="number">0.0</span>,    <span class="number">0.0</span>, <span class="number">-1.0</span>),   <span class="number">0.5</span>, material_center));</span><br><span class="line">world.add(make_shared&lt;sphere&gt;(point3(<span class="number">-1.0</span>,    <span class="number">0.0</span>, <span class="number">-1.0</span>),   <span class="number">0.5</span>, material_left));</span><br><span class="line">world.add(make_shared&lt;sphere&gt;(point3(<span class="number">-1.0</span>,    <span class="number">0.0</span>, <span class="number">-1.0</span>),  <span class="number">-0.4</span>, material_left));</span><br><span class="line">world.add(make_shared&lt;sphere&gt;(point3( <span class="number">1.0</span>,    <span class="number">0.0</span>, <span class="number">-1.0</span>),   <span class="number">0.5</span>, material_right));</span><br></pre></td></tr></table></figure><p><img src="/pictures/RayTracing/07/5.png" alt="A hollow glass sphere"></p>]]></content>
      
      
      <categories>
          
          <category> Ray Tracing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wxWidgets学习笔记01</title>
      <link href="2020/11/12/wxWidgets%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
      <url>2020/11/12/wxWidgets%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Hello-World"><a href="#一、Hello-World" class="headerlink" title="一、Hello World"></a>一、Hello World</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HelloWorldApp.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INCLUDED_HELLOWORLDAPP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INCLUDED_HELLOWORLDAPP_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The HelloWorldApp class. This class shows a window</span></span><br><span class="line"><span class="comment">// containing a statusbar with the text &quot;Hello World&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApp</span> :</span> <span class="keyword">public</span> wxApp</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">OnInit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DECLARE_APP(HelloWorldApp)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// INCLUDED_HELLOWORLDAPP_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HelloWorldApp.cpp</span></span><br><span class="line"><span class="comment">// For compilers that don&#x27;t support precompilation, include &quot;wx/wx.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wx/wxprec.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WX_PRECOMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wx/wx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;HelloWorldApp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">IMPLEMENT_APP(HelloWorldApp)</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is executed upon startup, like &#x27;main()&#x27; in non-wxWidgets programs.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HelloWorldApp::OnInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">wxFrame *frame = <span class="keyword">new</span> wxFrame((wxFrame*) <span class="literal">NULL</span>, <span class="number">-1</span>, _T(<span class="string">&quot;Hello wxWidgets World&quot;</span>));</span><br><span class="line">frame-&gt;CreateStatusBar();</span><br><span class="line">frame-&gt;SetStatusText(_T(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">frame-&gt;Show(<span class="literal">true</span>);</span><br><span class="line">SetTopWindow(frame);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于主窗口，使用wxFrame类。 此类提供了一个窗口，用户可以更改其大小和位置。 它具有粗边框和标题栏。 另外，您可以为其提供菜单栏，状态栏和工具栏。</p><p>当编译器支持预编译头时，可以使用wxprec.h。 如果没有，则应包括wx.h，其中包括wxWindow的所有必需头文件。 您还可以为每个控件分别包含每个头文件。</p><p><strong>宏DECLARE_APP和IMPLEMENT_APP为我们执行以下操作：</strong></p><p>①当需要一个平台时，它将创建一个main（）或WinMain（）方法。</p><p>②它创建全局方法wxGetApp（）。 您可以使用此函数来检索对一个应用程序对象的引用：<code>HelloWorldApp &amp;app = ::wxGetApp();</code></p><h2 id="二、Using-WxFrame"><a href="#二、Using-WxFrame" class="headerlink" title="二、Using  WxFrame"></a>二、Using  WxFrame</h2><p>wxFrame类为我们提供了一个框架窗口。 框架窗口是可以更改其大小的窗口。 它具有粗边框，标题栏，并且可以选择包含菜单栏，工具栏或状态栏。 框架可以充当其他控件的容器，但另一个框架或对话框除外。  wxFrame是从wxWindow派生的。</p><p>在本章中，我们将创建一个小型文本编辑器。</p><h3 id="1-Creating-a-frame"><a href="#1-Creating-a-frame" class="headerlink" title="1.Creating a frame"></a>1.Creating a frame</h3><p>通常，我们会创建派生自wxFrame的类。 这样，可以向自己的框架类添加功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TextFrame.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TEXTFRAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TEXTFRAME_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextFrame</span> :</span> <span class="keyword">public</span> wxFrame</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructor. Creates a new TextFrame</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   TextFrame(<span class="keyword">const</span> wxChar *title, <span class="keyword">int</span> xpos, <span class="keyword">int</span> ypos, <span class="keyword">int</span> width, <span class="keyword">int</span> height);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Destructor</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   ~TextFrame();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_TEXTFRAME_H</span></span></span><br></pre></td></tr></table></figure><p>从TextFrame构造函数调用wxFrame的构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TextFrame.c</span></span><br><span class="line"><span class="comment">// For compilers that don&#x27;t support precompilation, include &quot;wx/wx.h&quot;;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wx/wxprec.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WX_PRECOMP</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wx/wx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TextFrame.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TextFrame::TextFrame(<span class="keyword">const</span> wxChar *title, <span class="keyword">int</span> xpos, <span class="keyword">int</span> ypos, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span><br><span class="line">    : wxFrame((wxFrame *) <span class="literal">NULL</span>, <span class="number">-1</span>, title, wxPoint(xpos, ypos), wxSize(width, height))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TextFrame::~TextFrame()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-The-Frame-Constructor"><a href="#2-The-Frame-Constructor" class="headerlink" title="2.The Frame Constructor"></a>2.The Frame Constructor</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TextEditorApp.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEXTEDITORAPP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEXTEDITORAPP_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextEditorApp</span> :</span> <span class="keyword">public</span> wxApp</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/** Initialize the application */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">OnInit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DECLARE_APP(TextEditorApp)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TEXTEDITORAPP_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TextEditorApp.c</span></span><br><span class="line"><span class="comment">// For compilers that don&#x27;t support precompilation, include &quot;wx/wx.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wx/wxprec.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WX_PRECOMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wx/wx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TextEditorApp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TextFrame.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">IMPLEMENT_APP(TextEditorApp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TextEditorApp::OnInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TextFrame *frame = <span class="keyword">new</span> TextFrame(</span><br><span class="line">wxT(<span class="string">&quot;Simple Text Editor&quot;</span>), <span class="number">100</span>, <span class="number">100</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">frame-&gt;Show(TRUE);</span><br><span class="line">SetTopWindow(frame);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这之前都很简单，就是和Hello World那里一样。创建了一个空白窗体。</p><h2 id="3-Adding-A-Control"><a href="#3-Adding-A-Control" class="headerlink" title="3.Adding A Control"></a>3.Adding A Control</h2><p><strong>step1-The TextFrame Definition</strong></p><p>现在已经创建了框架窗口，需要添加一个用于处理文本的控件。 需要使用 wxTextCtrl类。 框架类已经包含此控件。此代码显示了TextFrame类的新定义。 唯一更改的是添加了wxTextCtrl类型的成员。 该成员在构造函数中初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TEXTFRAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TEXTFRAME_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextFrame</span> :</span> <span class="keyword">public</span> wxFrame</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor. Creates a new TextFrame</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TextFrame(<span class="keyword">const</span> wxString&amp; title, <span class="keyword">int</span> xpos, <span class="keyword">int</span> ypos, <span class="keyword">int</span> width, <span class="keyword">int</span> height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Destructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~TextFrame();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    wxTextCtrl *m_pTextCtrl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _TEXTFRAME_H</span></span></span><br></pre></td></tr></table></figure><p><strong>Step 2 - The TextFrame Implementation</strong></p><p>以下代码显示了TextFrame类的新构造函数。  wxTextCtrl成员的父级是TextFrame，因此我们将其传递给’this’指针。 文本’Type some text…’将显示为默认文本。 请注意，wxTextCtrl的构造函数看起来与wxFrame的构造函数相似。 从wxWindow派生的每个类都遵循相同的构造函数模式。</p><p>同样，没有用于删除wxTextCtrl指针的代码。 不必要（实际上是不允许的），因为TextFrame是父级，在销毁它时会自动删除其所有子级。</p><p><strong>wxTE_MULTILINE</strong>是文本控件的特定窗口样式。 此样式表示wxTextCtrl允许多行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For compilers that supports precompilation , include &quot;wx/wx.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wx/wxprec.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WX_PRECOMP</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span> <span class="meta-string">&quot;wx/wx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TextFrame.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TextFrame::TextFrame(<span class="keyword">const</span> wxString&amp; title, <span class="keyword">int</span> xpos, <span class="keyword">int</span> ypos, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span><br><span class="line">: wxFrame((wxFrame *) <span class="literal">NULL</span>, <span class="number">-1</span>, title, wxPoint(xpos, ypos), wxSize(width, height))</span><br><span class="line">&#123;</span><br><span class="line">    m_pTextCtrl = <span class="keyword">new</span> wxTextCtrl(<span class="keyword">this</span>, <span class="number">-1</span>, wxT(<span class="string">&quot;Type some text...&quot;</span>),</span><br><span class="line">                                 wxDefaultPosition, wxDefaultSize, wxTE_MULTILINE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// More will be added here later</span></span><br><span class="line"></span><br><span class="line">    Layout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TextFrame::~TextFrame()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行此项目时，将有一个应用程序，该应用程序显示一个窗口，可以在其中输入一些文本。 尝试剪切，粘贴。</p><p>之所以调用Layout（）是因为Windows并不总是在合适的时间发送size-event，以使wxWidgets能够捕获OnSize处理程序（在此它本身调用Layout（））。</p><p><img src="/pictures/wxWidgets/01/1.png" alt="运行结果"></p><h2 id="4-Adding-A-Menubar"><a href="#4-Adding-A-Menubar" class="headerlink" title="4.Adding A Menubar"></a>4.Adding A Menubar</h2><p>菜单在任何应用程序中都起着重要作用。 它们作为一个位置，大多数用户知道他们可以找到对应用程序中任何功能或模式的访问。  wxWidgets提供了三个主要类来管理应用程序中的菜单：wxMenuBar，wxMenu和wxMenuItem。</p><p>每个菜单项都需要一个唯一的ID。  #define不用于定义常量（例如#define MENU_FILE_MENU 1），因为这不能保证唯一的ID。 忽略某些值很容易，而且当你必须插入新ID时也很难维护。 如果未使用枚举定义菜单ID，则第二种流行的ID定义方法是使用wxNewId（）函数返回未使用的ID。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TextFrame.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TEXTFRAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TEXTFRAME_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextFrame</span> :</span> <span class="keyword">public</span> wxFrame</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor. Creates a new TextFrame */</span></span><br><span class="line">    TextFrame(<span class="keyword">const</span> wxChar *title, <span class="keyword">int</span> xpos, <span class="keyword">int</span> ypos, <span class="keyword">int</span> width, <span class="keyword">int</span> height);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    wxTextCtrl *m_pTextCtrl;</span><br><span class="line">    wxMenuBar *m_pMenuBar;</span><br><span class="line">    wxMenu *m_pFileMenu;</span><br><span class="line">    wxMenu *m_pHelpMenu;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> _TEXTFRAME_H</span></span><br></pre></td></tr></table></figure><p>菜单栏在TextFrame的构造函数中创建，如下所示。 使用wxMenu的Append方法将菜单项添加到菜单。  创建菜单后，可以使用wxMenuBar的Append将其附加到菜单栏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TextFrame.c</span></span><br><span class="line"><span class="comment">// For compilers that supports precompilation , includes &quot;wx/wx.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wx/wxprec.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WX_PRECOMP</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wx/wx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TextFrame.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TextFrame::TextFrame(<span class="keyword">const</span> wxChar *title, <span class="keyword">int</span> xpos, <span class="keyword">int</span> ypos, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span><br><span class="line">    : wxFrame((wxFrame *) <span class="literal">NULL</span>, <span class="number">-1</span>, title, wxPoint(xpos, ypos), wxSize(width, height))</span><br><span class="line">&#123;</span><br><span class="line">    m_pTextCtrl = <span class="keyword">new</span> wxTextCtrl(<span class="keyword">this</span>, <span class="number">-1</span>, _T(<span class="string">&quot;Type some text...&quot;</span>),</span><br><span class="line">                       wxDefaultPosition, wxDefaultSize, wxTE_MULTILINE);</span><br><span class="line"></span><br><span class="line">    m_pMenuBar = <span class="keyword">new</span> wxMenuBar();</span><br><span class="line">    <span class="comment">// File Menu</span></span><br><span class="line">    m_pFileMenu = <span class="keyword">new</span> wxMenu();</span><br><span class="line">    m_pFileMenu-&gt;Append(wxID_OPEN, _T(<span class="string">&quot;&amp;Open&quot;</span>));</span><br><span class="line">    m_pFileMenu-&gt;Append(wxID_SAVE, _T(<span class="string">&quot;&amp;Save&quot;</span>));</span><br><span class="line">    m_pFileMenu-&gt;AppendSeparator();<span class="comment">//添加一个分割符</span></span><br><span class="line">    m_pFileMenu-&gt;Append(wxID_EXIT, _T(<span class="string">&quot;&amp;Quit&quot;</span>));</span><br><span class="line">    m_pMenuBar-&gt;Append(m_pFileMenu, _T(<span class="string">&quot;&amp;File&quot;</span>));</span><br><span class="line">    <span class="comment">// About menu</span></span><br><span class="line">    m_pHelpMenu = <span class="keyword">new</span> wxMenu();</span><br><span class="line">    m_pHelpMenu-&gt;Append(wxID_ABOUT, _T(<span class="string">&quot;&amp;About&quot;</span>));</span><br><span class="line">    m_pMenuBar-&gt;Append(m_pHelpMenu, _T(<span class="string">&quot;&amp;Help&quot;</span>));</span><br><span class="line"></span><br><span class="line">    SetMenuBar(m_pMenuBar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上就是wxMenuBar下添加了两个wxMenu，一个是File，一个是Help。其中File下有Open，Save和Quit三个子菜单，Help下有About一个子菜单。</p><p><img src="/pictures/wxWidgets/01/2.png" alt="运行效果"></p><h2 id="5-Adding-A-Statusbar"><a href="#5-Adding-A-Statusbar" class="headerlink" title="5.Adding A Statusbar"></a>5.Adding A Statusbar</h2><p>将状态栏添加到框架甚至更加容易。 调用wxFrame方法CreateStatusBar，并且框架具有状态栏。 作为参数，将传递一个数字，该数字用于在状态栏中创建单独的字段。 使用SetStatusText可以更改字段的文本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TextFrame.c</span></span><br><span class="line">CreateStatusBar(<span class="number">3</span>);</span><br><span class="line">SetStatusText(wxT(<span class="string">&quot;Ready&quot;</span>), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这将创建一个包含3个字段的状态栏。 第一个字段将包含文本“Ready”。<br>状态栏也可用于显示所选菜单的描述。 下面的代码显示了如何更改“添加菜单栏”中的代码。 选择菜单后，相关描述将显示在状态栏的第一个字段中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////TextFrame.c</span></span><br><span class="line"><span class="comment">// File menu</span></span><br><span class="line">m_pFileMenu = <span class="keyword">new</span> wxMenu();</span><br><span class="line">m_pFileMenu-&gt;Append(wxID_OPEN, _T(<span class="string">&quot;&amp;Open&quot;</span>), _T(<span class="string">&quot;Opens an existing file&quot;</span>));</span><br><span class="line">m_pFileMenu-&gt;Append(wxID_SAVE, _T(<span class="string">&quot;&amp;Save&quot;</span>), _T(<span class="string">&quot;Save the content&quot;</span>));</span><br><span class="line">m_pFileMenu-&gt;AppendSeparator();</span><br><span class="line">m_pFileMenu-&gt;Append(wxID_EXIT, _T(<span class="string">&quot;&amp;Quit&quot;</span>), _T(<span class="string">&quot;Quit the application&quot;</span>));</span><br><span class="line">m_pMenuBar-&gt;Append(m_pFileMenu, _T(<span class="string">&quot;&amp;File&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// About menu</span></span><br><span class="line">m_pHelpMenu = <span class="keyword">new</span> wxMenu();</span><br><span class="line">m_pHelpMenu-&gt;Append(wxID_ABOUT, _T(<span class="string">&quot;&amp;About&quot;</span>), _T(<span class="string">&quot;Shows information about the application&quot;</span>));</span><br><span class="line">m_pMenuBar-&gt;Append(m_pHelpMenu, _T(<span class="string">&quot;&amp;Info&quot;</span>));</span><br></pre></td></tr></table></figure><p><img src="/pictures/wxWidgets/01/3.png" alt="运行效果"></p><h2 id="6-Processing-Menu-Events"><a href="#6-Processing-Menu-Events" class="headerlink" title="6.Processing Menu Events"></a>6.Processing Menu Events</h2><p>既然框架上有菜单，那么当用户选择菜单时，就需要一种实现操作的方法。 菜单的每个选择都会生成一个事件。</p><p>关于事件部分后面再说。提供添加事件后的最终版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TextFrame.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TEXTFRAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TEXTFRAME_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextFrame</span> :</span> <span class="keyword">public</span> wxFrame</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Constructor. Creates a new TextFrame */</span></span><br><span class="line">TextFrame(<span class="keyword">const</span> wxChar* title, <span class="keyword">int</span> xpos, <span class="keyword">int</span> ypos, <span class="keyword">int</span> width, <span class="keyword">int</span> height);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Processes menu File|Open */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnMenuFileOpen</span><span class="params">(wxCommandEvent&amp; event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Processes menu File|Save */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnMenuFileSave</span><span class="params">(wxCommandEvent&amp; event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Processes menu File|Quit */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnMenuFileQuit</span><span class="params">(wxCommandEvent&amp; event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Processes menu About|Info */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnMenuHelpAbout</span><span class="params">(wxCommandEvent&amp; event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">DECLARE_EVENT_TABLE()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">wxTextCtrl* m_pTextCtrl;</span><br><span class="line">wxMenuBar* m_pMenuBar;</span><br><span class="line">wxMenu* m_pFileMenu;</span><br><span class="line">wxMenu* m_pHelpMenu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> _TEXTFRAME_H</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TextFrame.c</span></span><br><span class="line"><span class="comment">// For compilers that supports precompilation , includes &quot;wx/wx.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wx/wxprec.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WX_PRECOMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wx/wx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TextFrame.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TextFrame::TextFrame(<span class="keyword">const</span> wxChar* title, <span class="keyword">int</span> xpos, <span class="keyword">int</span> ypos, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span><br><span class="line">: wxFrame((wxFrame*)<span class="literal">NULL</span>, <span class="number">-1</span>, title, wxPoint(xpos, ypos), wxSize(width, height))</span><br><span class="line">&#123;</span><br><span class="line">m_pTextCtrl = <span class="keyword">new</span> wxTextCtrl(<span class="keyword">this</span>, <span class="number">-1</span>, _T(<span class="string">&quot;Type some text...&quot;</span>),</span><br><span class="line">wxDefaultPosition, wxDefaultSize, wxTE_MULTILINE);</span><br><span class="line"></span><br><span class="line">CreateStatusBar(<span class="number">3</span>);</span><br><span class="line">SetStatusText(_T(<span class="string">&quot;Ready&quot;</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">m_pMenuBar = <span class="keyword">new</span> wxMenuBar();</span><br><span class="line"><span class="comment">// File menu</span></span><br><span class="line">m_pFileMenu = <span class="keyword">new</span> wxMenu();</span><br><span class="line">m_pFileMenu-&gt;Append(wxID_OPEN, _T(<span class="string">&quot;&amp;Open&quot;</span>), _T(<span class="string">&quot;Opens an existing file&quot;</span>));</span><br><span class="line">m_pFileMenu-&gt;Append(wxID_SAVE, _T(<span class="string">&quot;&amp;Save&quot;</span>), _T(<span class="string">&quot;Save the content&quot;</span>));</span><br><span class="line">m_pFileMenu-&gt;AppendSeparator();</span><br><span class="line">m_pFileMenu-&gt;Append(wxID_EXIT, _T(<span class="string">&quot;&amp;Quit&quot;</span>), _T(<span class="string">&quot;Quit the application&quot;</span>));</span><br><span class="line">m_pMenuBar-&gt;Append(m_pFileMenu, _T(<span class="string">&quot;&amp;File&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// About menu</span></span><br><span class="line">m_pHelpMenu = <span class="keyword">new</span> wxMenu();</span><br><span class="line">m_pHelpMenu-&gt;Append(wxID_ABOUT, _T(<span class="string">&quot;&amp;About&quot;</span>), _T(<span class="string">&quot;Shows information about the application&quot;</span>));</span><br><span class="line">m_pMenuBar-&gt;Append(m_pHelpMenu, _T(<span class="string">&quot;&amp;Info&quot;</span>));</span><br><span class="line"></span><br><span class="line">SetMenuBar(m_pMenuBar);</span><br><span class="line"></span><br><span class="line">Layout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If you&#x27;re doing an application by inheriting from wxApp</span></span><br><span class="line"><span class="comment">// be sure to change wxFrame to wxApp (or whatever component</span></span><br><span class="line"><span class="comment">// you&#x27;ve inherited your class from).</span></span><br><span class="line">BEGIN_EVENT_TABLE(TextFrame, wxFrame)</span><br><span class="line">EVT_MENU(wxID_OPEN, TextFrame::OnMenuFileOpen)</span><br><span class="line">EVT_MENU(wxID_SAVE, TextFrame::OnMenuFileSave)</span><br><span class="line">EVT_MENU(wxID_EXIT, TextFrame::OnMenuFileQuit)</span><br><span class="line">EVT_MENU(wxID_ABOUT, TextFrame::OnMenuHelpAbout)</span><br><span class="line">END_EVENT_TABLE()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TextFrame::OnMenuFileOpen</span><span class="params">(wxCommandEvent&amp; event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">wxFileDialog* OpenDialog = <span class="keyword">new</span> wxFileDialog(<span class="keyword">this</span>, _T(<span class="string">&quot;Choose a file&quot;</span>), _(<span class="string">&quot;&quot;</span>), _(<span class="string">&quot;&quot;</span>), _(<span class="string">&quot;*.*&quot;</span>), wxFD_OPEN);</span><br><span class="line"><span class="keyword">if</span> (OpenDialog-&gt;ShowModal() == wxID_OK)</span><br><span class="line">&#123;</span><br><span class="line">m_pTextCtrl-&gt;LoadFile(OpenDialog-&gt;GetPath()) ?</span><br><span class="line">SetStatusText(_T(<span class="string">&quot;Loaded&quot;</span>)) :</span><br><span class="line">SetStatusText(_T(<span class="string">&quot;Load Failed&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">OpenDialog-&gt;Close(); <span class="comment">// Or OpenDialog-&gt;Destroy() ?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TextFrame::OnMenuFileSave</span><span class="params">(wxCommandEvent&amp; event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">wxFileDialog* SaveDialog = <span class="keyword">new</span> wxFileDialog(<span class="keyword">this</span>, _T(<span class="string">&quot;Choose a file&quot;</span>), _(<span class="string">&quot;&quot;</span>), _(<span class="string">&quot;&quot;</span>), _(<span class="string">&quot;*.*&quot;</span>), wxFD_SAVE);</span><br><span class="line"><span class="keyword">if</span> (SaveDialog-&gt;ShowModal() == wxID_OK)</span><br><span class="line">&#123;</span><br><span class="line">m_pTextCtrl-&gt;SaveFile(SaveDialog-&gt;GetPath()) ?</span><br><span class="line">SetStatusText(_T(<span class="string">&quot;Saved&quot;</span>)) :</span><br><span class="line">SetStatusText(_T(<span class="string">&quot;Save Failed&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">SaveDialog-&gt;Close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TextFrame::OnMenuFileQuit</span><span class="params">(wxCommandEvent&amp; event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Close(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TextFrame::OnMenuHelpAbout</span><span class="params">(wxCommandEvent&amp; event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">wxLogMessage(_T(<span class="string">&quot;The Simple Text Editor&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> wxWidgets </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wxWidgets </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vs2019搭建wxWidgets环境的配置方法</title>
      <link href="2020/11/12/vs2019%E6%90%AD%E5%BB%BAwxWidgets%E7%8E%AF%E5%A2%83%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
      <url>2020/11/12/vs2019%E6%90%AD%E5%BB%BAwxWidgets%E7%8E%AF%E5%A2%83%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h4 id="1-下载"><a href="#1-下载" class="headerlink" title="1.下载"></a>1.下载</h4><p>官网：<a href="https://www.wxwidgets.org/downloads/">https://www.wxwidgets.org/downloads/</a></p><p><img src="/pictures/wxWidgets/00/1.png" alt="下载方式"></p><p>下载zip文件即可，也可以下载右边的官方文档。解压路径不要有空格和中文！！！我的解压路径是(D:\wxWidgets-3.1.4)</p><h4 id="2-添加环境变量"><a href="#2-添加环境变量" class="headerlink" title="2.添加环境变量"></a>2.添加环境变量</h4><p><img src="/pictures/wxWidgets/00/2.png" alt="更改环境变量"></p><p>在系统变量里面添加：变量名：<strong>WXWIN</strong>  值：<strong>D:\wxWidgets-3.1.4</strong>（就是你的解压路径，文件夹的绝对路径）</p><h4 id="3-编译源码"><a href="#3-编译源码" class="headerlink" title="3.编译源码"></a>3.编译源码</h4><p>找到这个路径：<strong>D:\wxWidgets-3.1.4\build\msw</strong>下的 <strong>wx_vc16.sln</strong>，用vs2019打开。</p><p><em>官方文档中列出的 VC 与 MSVS 对应关系：</em></p><p><em>VC++ 7, 8, 9, 10, 11, 12, 14, 15 and 16 ( MSVS 2003, 2005, 2008, 2010, 2012, 2013, 2015, 2017 and 2019)</em></p><p>选择Debug，x64，配置类型选择静态库！然后生成解决方案。这样就在D:\wxWidgets-3.1.4\lib路径下生成了vc_x64_lib文件夹。</p><p><img src="/pictures/wxWidgets/00/3.png" alt="修改配置属性"></p><h4 id="4-项目配置"><a href="#4-项目配置" class="headerlink" title="4.项目配置"></a>4.项目配置</h4><p>创建一个空项目，编辑工程属性，须在【项目属性页】做如下修改：</p><p>配置属性 - C/C++ - 常规 - 附加包含目录：添加 $(WXWIN)\include\msvc 和 $(WXWIN)\include</p><p>配置属性 - C/C++ - 预处理器 - 预处理器定义：添加 <strong>WXMSW</strong> 、_UNICODE、NDEBUG，这里若不加_UNICODE，则需要在 配置属性 - 高级 - 高级属性 - 字符集 选择【使用 Unicode 字符集】</p><p>配置属性 - 链接器 - 常规 - 附加库目录：添加 $(WXWIN)\lib\vc_x64_lib</p><p>配置属性 - 链接器 - 系统 - 子系统：选择【窗口】（默认为【控制台】）</p><h4 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h4><p>官方hello word测试案例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wx\wxprec.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wx\wx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WX_PRECOMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;include\wx\wx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> :</span> <span class="keyword">public</span> wxApp</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">OnInit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFrame</span> :</span> <span class="keyword">public</span> wxFrame &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MyFrame(<span class="keyword">const</span> wxString&amp; title, <span class="keyword">const</span> wxPoint&amp; pos, <span class="keyword">const</span> wxSize&amp; size);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnHello</span><span class="params">(wxCommandEvent&amp; event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnExit</span><span class="params">(wxCommandEvent&amp; event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnAbout</span><span class="params">(wxCommandEvent&amp; event)</span></span>;</span><br><span class="line">wxDECLARE_EVENT_TABLE();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">ID_Hello = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">wxBEGIN_EVENT_TABLE(MyFrame, wxFrame)</span><br><span class="line">EVT_MENU(ID_Hello, MyFrame::OnHello)</span><br><span class="line">EVT_MENU(wxID_EXIT, MyFrame::OnExit)</span><br><span class="line">EVT_MENU(wxID_ABOUT, MyFrame::OnAbout)</span><br><span class="line">wxEND_EVENT_TABLE()</span><br><span class="line">wxIMPLEMENT_APP(MyApp);</span><br><span class="line"><span class="comment">// main function this macro is the main function</span></span><br><span class="line"><span class="comment">// create an application instance and starts the program</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MyApp::OnInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyFrame* frame = <span class="keyword">new</span> MyFrame(<span class="string">&quot;Hello World&quot;</span>, wxPoint(<span class="number">50</span>, <span class="number">50</span>), wxSize(<span class="number">450</span>, <span class="number">340</span>));</span><br><span class="line">frame-&gt;Show(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">MyFrame::MyFrame(<span class="keyword">const</span> wxString&amp; title, <span class="keyword">const</span> wxPoint&amp; pos, <span class="keyword">const</span> wxSize&amp; size)</span><br><span class="line">: wxFrame(<span class="literal">NULL</span>, wxID_ANY, title, pos, size)</span><br><span class="line">&#123;</span><br><span class="line">wxMenu* menuFile = <span class="keyword">new</span> wxMenu;</span><br><span class="line">menuFile-&gt;Append(ID_Hello, <span class="string">&quot;&amp;Hello...\tCtrl-H&quot;</span>,</span><br><span class="line"><span class="string">&quot;Hello string show in status bar for this menu item&quot;</span>);</span><br><span class="line">menuFile-&gt;AppendSeparator();</span><br><span class="line">menuFile-&gt;Append(wxID_EXIT);</span><br><span class="line"> </span><br><span class="line">wxMenu* menuHelp = <span class="keyword">new</span> wxMenu;</span><br><span class="line">menuHelp-&gt;Append(wxID_ABOUT);</span><br><span class="line"> </span><br><span class="line">wxMenuBar* menuBar = <span class="keyword">new</span> wxMenuBar;</span><br><span class="line">menuBar-&gt;Append(menuFile, <span class="string">&quot;&amp;File&quot;</span>);</span><br><span class="line">menuBar-&gt;Append(menuHelp, <span class="string">&quot;&amp;Help&quot;</span>);</span><br><span class="line"> </span><br><span class="line">SetMenuBar(menuBar);</span><br><span class="line"> </span><br><span class="line">CreateStatusBar();</span><br><span class="line">SetStatusText(<span class="string">&quot;Welcome to wxWidgets!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFrame::OnExit</span><span class="params">(wxCommandEvent&amp; event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Close(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFrame::OnAbout</span><span class="params">(wxCommandEvent&amp; event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">wxMessageBox(<span class="string">&quot;This is a wxWidgets&#x27; Hello World sample&quot;</span>, <span class="string">&quot;About Hello World&quot;</span>, wxOK | wxICON_INFORMATION);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFrame::OnHello</span><span class="params">(wxCommandEvent&amp; event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">wxLogMessage(<span class="string">&quot;Hello world from wxWidgets!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-运行结果"><a href="#6-运行结果" class="headerlink" title="6.运行结果"></a>6.运行结果</h4><p><img src="/pictures/wxWidgets/00/4.png" alt="运行结果"></p>]]></content>
      
      
      <categories>
          
          <category> wxWidgets </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wxWidgets </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C++Primer第五版》学习笔记--第0部分</title>
      <link href="2020/11/11/%E3%80%8AC++Primer%E7%AC%AC%E4%BA%94%E7%89%88%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0--%E7%AC%AC0%E9%83%A8%E5%88%86/"/>
      <url>2020/11/11/%E3%80%8AC++Primer%E7%AC%AC%E4%BA%94%E7%89%88%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0--%E7%AC%AC0%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-zwdTXUKa" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1481164987" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#3F51B5"    ></div><h2 id="第0部分"><a href="#第0部分" class="headerlink" title="第0部分"></a>第0部分</h2><h3 id="第1章-开始"><a href="#第1章-开始" class="headerlink" title="第1章 开始"></a><strong>第1章 开始</strong></h3><h4 id="1-1编写一个简单的C-程序"><a href="#1-1编写一个简单的C-程序" class="headerlink" title="1.1编写一个简单的C++程序"></a>1.1编写一个简单的C++程序</h4><p>每个C++程序都包含一个或多个函数，其中一个必须命名为main。操作系统通过调用main来运行C++程序。这是非常简单的main函数，只是返回给操作系统一个值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个函数定义包括四部分：返回类型、函数名、一个括号包围的形参列表以及函数体。</p><p>IDE全称Intergrated Development Environment，集成开发环境</p><h4 id="1-2初识输入输出"><a href="#1-2初识输入输出" class="headerlink" title="1.2初识输入输出"></a>1.2初识输入输出</h4><p>C++语言并未定义任何输入输出(IO)语句，但包含一个全面的标准库来提供IO机制。本书中很多示例都是使用的iostream库，该库包含istream和ostream，分别代表输入流和输出流。标准库定义了4个IO对象，cin:标准输入；cout:标准输出；cerr:标准错误；clog:输出程序运行时的一般性信息。</p><h4 id="1-3注释简介"><a href="#1-3注释简介" class="headerlink" title="1.3注释简介"></a>1.3注释简介</h4><p>单行注释：//</p><p>多行注释：以/* 开始，以 */结束</p><h4 id="1-4控制流"><a href="#1-4控制流" class="headerlink" title="1.4控制流"></a>1.4控制流</h4><h5 id="1-4-1-while语句"><a href="#1-4-1-while语句" class="headerlink" title="1.4.1 while语句"></a>1.4.1 while语句</h5><p>while语句反复执行一段代码，直至给定的条件为假为止。</p><h5 id="1-4-2-for语句"><a href="#1-4-2-for语句" class="headerlink" title="1.4.2 for语句"></a>1.4.2 for语句</h5><p>for语句是为了简化循环条件中检测变量、在循环体中递增变量的模式。</p><h5 id="1-4-3-读取数量不定的输入数据"><a href="#1-4-3-读取数量不定的输入数据" class="headerlink" title="1.4.3 读取数量不定的输入数据"></a>1.4.3 读取数量不定的输入数据</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;value)</span><br></pre></td></tr></table></figure><p>while循环条件的求值就是执行表达式<code>std::cin&gt;&gt;value</code>，此表达式从标准输入读取下一个数，保存在value中。因此循环条件实际上是检测的是<code>std::cin</code>。当我们使用一个istream对象作为条件时，其效果是检测流的状态。如果流失有效的，即流未遇到错误，那么检测成功。当遇到文件结束符，或遇到一个无效输入时，istream对象的状态会变为无效。处于无效状态的istream对象会使条件变为假。</p><p>ps：从键盘输入文件结束符。Windows系统中是Ctrl+Z，然后按Enter或Return。Mac OS X系统中是Ctrl+D。</p><h5 id="1-4-4-if语句"><a href="#1-4-4-if语句" class="headerlink" title="1.4.4 if语句"></a>1.4.4 if语句</h5><p>if语句用来支持条件执行。</p><h4 id="1-5-类简介"><a href="#1-5-类简介" class="headerlink" title="1.5 类简介"></a>1.5 类简介</h4><p>在C++中，通过顶一个类(class)来定义自己的数据结构。一个类定义一个类型以及与其关联的一组操作。类机制是C++最重要的特性之一。</p><h5 id="1-5-1-Sales-item类"><a href="#1-5-1-Sales-item类" class="headerlink" title="1.5.1 Sales_item类"></a>1.5.1 Sales_item类</h5><p>关键概念：类定义了行为。一般而言，类的作者决定了类类型对象上可以使用的所有操作。</p><h5 id="1-5-2-初试成员函数"><a href="#1-5-2-初试成员函数" class="headerlink" title="1.5.2 初试成员函数"></a>1.5.2 初试成员函数</h5><p>成员函数是定义为类的一部分的函数，有时也被称为方法。通常以一个类对象的名义来调用成员函数。使用点(·)运算符来调用。点运算符只能用于类类型的对象。其左侧必须是一个类类型的对象，右侧对象必须是该类型的一个成员名，运算结果为右侧运算对象指定的成员。</p>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++之道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Ray Tracing in a Weekend》学习笔记06</title>
      <link href="2020/11/10/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B006/"/>
      <url>2020/11/10/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B006/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-jwumwWtP" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="30814948" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#3F51B5"    ></div><p><strong>9. Metal</strong></p><p><strong>9.1 An Abstract Class for Materials</strong></p><p>对于本项目，材料需要做两件事情一是产生散射射线（或者说它吸收了入射射线）二是如果是散射，说出应将射线衰减多少。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[material.h] The material class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MATERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MATERIAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hit_record</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">material</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>9.2 A Data Structure to Describe Ray-Object Intersections</strong></p><p>hit_record是为了避免使用一堆参数，因此我们可以在其中填充所需的任何信息。我只需告诉编译器，这个指针是一个类。像下面代码这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[hittable.h] Hit record with added material pointer</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">material</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hit_record</span> &#123;</span></span><br><span class="line">    point3 p;</span><br><span class="line">    vec3 normal;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;material&gt; mat_ptr;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">double</span> t;</span><br><span class="line">    <span class="keyword">bool</span> front_face;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_face_normal</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> vec3&amp; outward_normal)</span> </span>&#123;</span><br><span class="line">        front_face = dot(r.direction(), outward_normal) &lt; <span class="number">0</span>;</span><br><span class="line">        normal = front_face ? outward_normal :-outward_normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们在这里设置的是材料将告诉我们射线如何与表面相互作用。hit_record只是将一堆参数填充到结构中的一种方法。因此我们要将它们作为一组数据发送。当光线撞击表面（例如特定的球体）时，hit_record中的材质指针将被设置为指向在我们开始时在main()中设置该球体时所给定的材质指针。 当ray_color()例程获取hit_record时，它可以调用材质指针的成员函数来找出散射的光线（如果有）。</p><p>为此我们必须对在hit_record中返回的球形类的材料进行引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[sphere.h] Ray-sphere intersection with added material information</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sphere</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        sphere() &#123;&#125;</span><br><span class="line">        sphere(point3 cen, <span class="keyword">double</span> r, <span class="built_in">shared_ptr</span>&lt;material&gt; m)</span><br><span class="line">            : center(cen), radius(r), mat_ptr(m) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> tmin, <span class="keyword">double</span> tmax, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        point3 center;</span><br><span class="line">        <span class="keyword">double</span> radius;</span><br><span class="line">        <span class="built_in">shared_ptr</span>&lt;material&gt; mat_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sphere::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.origin() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.direction().length_squared();</span><br><span class="line">    <span class="keyword">auto</span> half_b = dot(oc, r.direction());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.length_squared() - radius*radius;</span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b*half_b - a*c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (discriminant &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line">        <span class="keyword">auto</span> temp = (-half_b - root) / a;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; t_max &amp;&amp; temp &gt; t_min) &#123;</span><br><span class="line">            rec.t = temp;</span><br><span class="line">            rec.p = r.at(rec.t);</span><br><span class="line">            vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">            rec.set_face_normal(r, outward_normal);</span><br><span class="line">            rec.mat_ptr = mat_ptr;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = (-half_b + root) / a;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; t_max &amp;&amp; temp &gt; t_min) &#123;</span><br><span class="line">            rec.t = temp;</span><br><span class="line">            rec.p = r.at(rec.t);</span><br><span class="line">            vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">            rec.set_face_normal(r, outward_normal);</span><br><span class="line">            rec.mat_ptr = mat_ptr;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>9.3 Modeling Light Scatter and Reflectance</strong></p><p>前面已经有了Lambertian反射，它既可以始终散射并通过其反射率R进行衰减，也可以不进行散射但吸收射线的1-R参数进行散射或者可以混合这些策略。针对Lambertian材料，可以得到下面这个类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[material.h] The lambertian material class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lambertian</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        lambertian(<span class="keyword">const</span> color&amp; a) : albedo(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            vec3 scatter_direction = rec.normal + random_unit_vector();</span><br><span class="line">            scattered = ray(rec.p, scatter_direction);</span><br><span class="line">            attenuation = albedo;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        color albedo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ps：这里我们也可以仅以某个概率p进行散射并衰减为albedo/p。</p><p><strong>9.4 Mirrored Light Reflection</strong></p><p>对于光滑的金属，射线不会被随机散射。这里涉及到向量的问题。</p><p><img src="/pictures/RayTracing/06/1.jpg" alt="Ray reflection"></p><p>如图所示，反射的方向是<strong>v+2b</strong>。n是单位向量，为该点的法向量，但v不是单位向量。<strong>b</strong>的长度应该是<strong>v·n</strong>。相当于<strong>v</strong>在<strong>n</strong>上的投影，但方向是与<strong>b</strong>方向相反，所以需要添加一个负号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[vec3.h] vec3 reflection function</span></span><br><span class="line"><span class="function">vec3 <span class="title">reflect</span><span class="params">(<span class="keyword">const</span> vec3&amp; v, <span class="keyword">const</span> vec3&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v - <span class="number">2</span>*dot(v,n)*n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>金属材料就只是使用该点的反射光线：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[material.h] Metal material with reflectance function</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">metal</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        metal(<span class="keyword">const</span> color&amp; a) : albedo(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="comment">//获取反射光线</span></span><br><span class="line">            vec3 reflected = reflect(unit_vector(r_in.direction()), rec.normal);</span><br><span class="line">            scattered = ray(rec.p, reflected);</span><br><span class="line">            attenuation = albedo;</span><br><span class="line">            <span class="keyword">return</span> (dot(scattered.direction(), rec.normal) &gt; <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        color albedo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改ray_color()函数以使用此函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [main.c] Ray color with scattered reflectance</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we&#x27;ve exceeded the ray bounce limit, no more light is gathered.</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> color(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (world.hit(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        ray scattered;</span><br><span class="line">        color attenuation;</span><br><span class="line">        <span class="keyword">if</span> (rec.mat_ptr-&gt;scatter(r, rec, attenuation, scattered))</span><br><span class="line">            <span class="keyword">return</span> attenuation * ray_color(scattered, world, depth<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> color(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3 unit_direction = unit_vector(r.direction());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.y() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*color(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*color(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>9.5 A Scene with Metal Spheres</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[main.cc] Scene with metal spheres</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;material.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Image</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> max_depth = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// World</span></span><br><span class="line"></span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material_ground = make_shared&lt;lambertian&gt;(color(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_center = make_shared&lt;lambertian&gt;(color(<span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_left   = make_shared&lt;metal&gt;(color(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.8</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_right  = make_shared&lt;metal&gt;(color(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>));</span><br><span class="line"></span><br><span class="line">    world.add(make_shared&lt;sphere&gt;(point3( <span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">    world.add(make_shared&lt;sphere&gt;(point3( <span class="number">0.0</span>,    <span class="number">0.0</span>, <span class="number">-1.0</span>),   <span class="number">0.5</span>, material_center));</span><br><span class="line">    world.add(make_shared&lt;sphere&gt;(point3(<span class="number">-1.0</span>,    <span class="number">0.0</span>, <span class="number">-1.0</span>),   <span class="number">0.5</span>, material_left));</span><br><span class="line">    world.add(make_shared&lt;sphere&gt;(point3( <span class="number">1.0</span>,    <span class="number">0.0</span>, <span class="number">-1.0</span>),   <span class="number">0.5</span>, material_right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Camera</span></span><br><span class="line"></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="keyword">auto</span> u = (i + random_double()) / (image_width<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + random_double()) / (image_height<span class="number">-1</span>);</span><br><span class="line">                ray r = cam.get_ray(u, v);</span><br><span class="line">                pixel_color += ray_color(r, world, max_depth);</span><br><span class="line">            &#125;</span><br><span class="line">            write_color(<span class="built_in">std</span>::<span class="built_in">cout</span>, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>9.6 Fuzzy Reflection</strong></p><p>还可以通过使用小球体，并为射线选择新的端点，以此来随机化反射方向：</p><p><img src="/pictures/RayTracing/06/2.jpg" alt="Generating fuzzed reflection rays"></p><p>球体越大，反射将变得越模糊。 这建议添加一个模糊度参数，该参数仅是球体的半径（因此零是没有扰动）。 要注意的是，对于大球体或掠食性射线，我们可能会散射到表面以下。 我们可以让表面吸收那些。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[material.h] Metal material fuzziness</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">metal</span> :</span> <span class="keyword">public</span> material &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        metal(<span class="keyword">const</span> color&amp; a, <span class="keyword">double</span> f) : albedo(a), fuzz(f &lt; <span class="number">1</span> ? f : <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            vec3 reflected = reflect(unit_vector(r_in.direction()), rec.normal);</span><br><span class="line">            scattered = ray(rec.p, reflected + fuzz*random_in_unit_sphere());</span><br><span class="line">            attenuation = albedo;</span><br><span class="line">            <span class="keyword">return</span> (dot(scattered.direction(), rec.normal) &gt; <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        color albedo;</span><br><span class="line">        <span class="keyword">double</span> fuzz;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以通过在金属上添加模糊度0.3和1.0来进行尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[main.cc] Metal spheres with fuzziness</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// World</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material_ground = make_shared&lt;lambertian&gt;(color(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_center = make_shared&lt;lambertian&gt;(color(<span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_left   = make_shared&lt;metal&gt;(color(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.8</span>), <span class="number">0.3</span>);</span><br><span class="line">    <span class="keyword">auto</span> material_right  = make_shared&lt;metal&gt;(color(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">1.0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pictures/RayTracing/06/3.png" alt="Fuzzed metal"></p>]]></content>
      
      
      <categories>
          
          <category> Ray Tracing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取windows锁屏壁纸</title>
      <link href="2020/11/10/%E8%8E%B7%E5%8F%96windows%E9%94%81%E5%B1%8F%E5%A3%81%E7%BA%B8/"/>
      <url>2020/11/10/%E8%8E%B7%E5%8F%96windows%E9%94%81%E5%B1%8F%E5%A3%81%E7%BA%B8/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-WCxhuLYo" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="445546453" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#3F51B5"    ></div><p><strong>1.找到windows锁屏壁纸的缓存位置</strong></p><p>win+r，在运行框中输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%localappdata%\Packages\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\LocalState\Assets</span><br></pre></td></tr></table></figure><p><img src="/pictures/windows/1.png" alt="运行框"></p><p>进入锁屏壁纸的缓存位置</p><p><img src="/pictures/windows/2.png" alt="锁屏壁纸缓存位置"></p><p><strong>2.新建批处理文件</strong></p><p>在缓存位置新建文本文档，输入以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ren *.* *.jpg</span><br></pre></td></tr></table></figure><p><img src="/pictures/windows/3.png" alt="输入代码"></p><p>保存后，将该文件的.txt后缀修改为.bat，批处理文件创建成功！</p><p><img src="/pictures/windows/4.png" alt="修改后缀"></p><p><strong>3.一键修改.jpg</strong></p><p>将缓存位置的所有文件（包括.bat文件）复制到一个新的文件夹（不要在原位置下新建文件夹），然后双击.bat文件，即可将所有文件修改为.jpg后缀。</p><p><img src="/pictures/windows/5.png" alt="一键修改.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常的奇奇怪怪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Ray Tracing in a Weekend》学习笔记05</title>
      <link href="2020/11/06/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B005/"/>
      <url>2020/11/06/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B005/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-rjbnqoSr" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="30814948" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#3F51B5"    ></div><h5 id="8-3-Using-Gamma-Correction-for-Accurate-Color-Intensity"><a href="#8-3-Using-Gamma-Correction-for-Accurate-Color-Intensity" class="headerlink" title="8.3 Using Gamma Correction for Accurate Color Intensity"></a>8.3 Using Gamma Correction for Accurate Color Intensity</h5><p><img src="/pictures/RayTracing/05/1.png" alt="First render of a diffuse sphere"></p><p>这张照片很暗，这个球体在现实生活中应该是浅灰色。我们的球体在每次反弹仅吸收一半的能量，因此是50%反射器。看上去暗的原因是几乎所有的图像查看器都是假定图像经过“伽马校正”的，这意味着0到1的值存储为字节之前会有一些变换。我们可以使用“伽马2”，也就是将颜色提升为1/gamma的幂，或者通常就是平方根。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[color.h] write_color(), with gamma correction</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_color</span><span class="params">(<span class="built_in">std</span>::ostream &amp;out, color pixel_color, <span class="keyword">int</span> samples_per_pixel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = pixel_color.x();</span><br><span class="line">    <span class="keyword">auto</span> g = pixel_color.y();</span><br><span class="line">    <span class="keyword">auto</span> b = pixel_color.z();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Divide the color by the number of samples and gamma-correct for gamma=2.0.</span></span><br><span class="line">    <span class="keyword">auto</span> scale = <span class="number">1.0</span> / samples_per_pixel;</span><br><span class="line">    r = <span class="built_in">sqrt</span>(scale * r);</span><br><span class="line">    g = <span class="built_in">sqrt</span>(scale * g);</span><br><span class="line">    b = <span class="built_in">sqrt</span>(scale * b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write the translated [0,255] value of each color component.</span></span><br><span class="line">    out &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * clamp(r, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * clamp(g, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * clamp(b, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pictures/RayTracing/05/2.png" alt="Diffuse sphere, with gamma correction"></p><h5 id="8-4-Fixing-Shadow-Acne"><a href="#8-4-Fixing-Shadow-Acne" class="headerlink" title="8.4 Fixing Shadow Acne"></a>8.4 Fixing Shadow Acne</h5><p>还有一个细微的错误。 一些反射的射线不是恰好在t = 0时撞击到它们所反射的对象，而是在t = -0.0000001或t = 0.00000001或球体相交给我们的任何浮点近似值处射出。 因此，我们需要忽略非常接近零的点击：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[main.cc] Calculating reflected ray origins with tolerance</span></span><br><span class="line"><span class="keyword">if</span> (world.hit(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br></pre></td></tr></table></figure><h5 id="8-5-True-Lambertian-Reflection"><a href="#8-5-True-Lambertian-Reflection" class="headerlink" title="8.5 True Lambertian Reflection"></a>8.5 True Lambertian Reflection</h5><p>这里介绍的方法是在单位球沿曲面法线偏移的位置产生随机点。这意味着接近法线的位置概率更高，偏离法线的位置概率较低。此分布是按cos^3(ϕ)缩放，ϕ是偏离方向与法线的夹角。这是合理的，因为以浅角度到达的光，会散布到更大的区域上，因此他们对最终颜色贡献较小。</p><p>我们对具有cos（ϕ）分布的Lambertian分布感兴趣。  True Lambertian射线接近法线的可能性更高，但是分布更均匀。 这是通过在单位球面上拾取沿曲面法线偏移的点来实现的。 可以通过在单位球中拾取点，然后对其进行归一化来获得球体上的拾取点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[vec3.h] The random_unit_vector() function</span></span><br><span class="line"><span class="comment">//单位球体表面上一点满足x^2+y^2+z^2=1;</span></span><br><span class="line"><span class="function">vec3 <span class="title">random_unit_vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = random_double(<span class="number">0</span>, <span class="number">2</span>*pi);</span><br><span class="line">    <span class="keyword">auto</span> z = random_double(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> r = <span class="built_in">sqrt</span>(<span class="number">1</span> - z*z);</span><br><span class="line">    <span class="keyword">return</span> vec3(r*<span class="built_in">cos</span>(a), r*<span class="built_in">sin</span>(a), z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pictures/RayTracing/05/3.png" alt="Generating a random unit vector"></p><p>该random_unit_vector（）替代了现有random_in_unit_sphere（）函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[main.c] ray_color() with replacement diffuse</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we&#x27;ve exceeded the ray bounce limit, no more light is gathered.</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> color(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (world.hit(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        point3 target = rec.p + rec.normal + random_unit_vector();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * ray_color(ray(rec.p, target - rec.p), world, depth<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3 unit_direction = unit_vector(r.direction());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.y() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*color(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*color(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pictures/RayTracing/05/4.png" alt="Correct rendering of Lambertian spheres"></p><p>这两个变化都是由于光线的散射更加均匀，朝法线散射的光线更少。 这意味着对于散射的物体，它们会显得更亮，因为更多的光会朝着相机反弹。 对于阴影，较少的光直接向上反射，因此较大球体的正下方较小球体的部分更亮。</p><h5 id="8-6-An-Alternative-Diffuse-Formulation"><a href="#8-6-An-Alternative-Diffuse-Formulation" class="headerlink" title="8.6  An Alternative Diffuse Formulation"></a>8.6  An Alternative Diffuse Formulation</h5><p>一种更直观的方法是，对于远离击点的所有角度都具有统一的散射方向，而不依赖于与法线的角度。 许多第一批射线追踪论文都使用这种扩散方法（在采用Lambertian散射之前）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[vec3.h] The random_in_hemisphere(normal) function</span></span><br><span class="line"><span class="function">vec3 <span class="title">random_in_hemisphere</span><span class="params">(<span class="keyword">const</span> vec3&amp; normal)</span> </span>&#123;</span><br><span class="line">    vec3 in_unit_sphere = random_in_unit_sphere();</span><br><span class="line">    <span class="keyword">if</span> (dot(in_unit_sphere, normal) &gt; <span class="number">0.0</span>) <span class="comment">// In the same hemisphere as the normal</span></span><br><span class="line">        <span class="keyword">return</span> in_unit_sphere;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -in_unit_sphere;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将新公式插入ray_color（）函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[main.c] ray_color() with hemispherical scattering</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we&#x27;ve exceeded the ray bounce limit, no more light is gathered.</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> color(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (world.hit(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        point3 target = rec.p + random_in_hemisphere(rec.normal);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * ray_color(ray(rec.p, target - rec.p), world, depth<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3 unit_direction = unit_vector(r.direction());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.y() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*color(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*color(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pictures/RayTracing/05/5.png" alt="Rendering of diffuse spheres with hemispherical scattering"></p>]]></content>
      
      
      <categories>
          
          <category> Ray Tracing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Ray Tracing in a Weekend》学习笔记04</title>
      <link href="2020/10/28/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004/"/>
      <url>2020/10/28/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-lxsMlOBj" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1487528112" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#3F51B5"    ></div><h4 id="7-Antialiasing"><a href="#7-Antialiasing" class="headerlink" title="7.  Antialiasing"></a>7.  Antialiasing</h4><p>这章要解决边缘锯齿的问题。</p><h5 id="7-2-Some-Random-Number-Utilities"><a href="#7-2-Some-Random-Number-Utilities" class="headerlink" title="7.2 Some Random Number Utilities"></a>7.2 Some Random Number Utilities</h5><p>首先需要的是一个返回真实随机数的随机数生成器。制作一个返回规范随机数的函数，该函数通常会返回0&lt;=r&lt;1范围内的随机实数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rtweekend.h  random_double() functions</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">random_double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Returns a random real in [0,1).</span></span><br><span class="line">    <span class="keyword">return</span> rand() / (RAND_MAX + <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">random_double</span><span class="params">(<span class="keyword">double</span> min, <span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Returns a random real in [min,max).</span></span><br><span class="line">    <span class="keyword">return</span> min + (max-min)*random_double();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C ++传统上没有标准的随机数生成器，但是较新版本的C ++已使用<random>标头解决了此问题。 如果要使用此函数，则可以按照以下条件获得随机数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rtweekend.h random_double(), alternate implemenation</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">random_double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mt19937 generator;</span><br><span class="line">    <span class="keyword">return</span> distribution(generator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-2-Generating-Pixels-with-Multiple-Samples"><a href="#7-2-Generating-Pixels-with-Multiple-Samples" class="headerlink" title="7.2  Generating Pixels with Multiple Samples"></a>7.2  Generating Pixels with Multiple Samples</h5><p><img src="/pictures/RayTracing/04/2.png" alt="之前运行结果"></p><p>上次的运行结果能很明显的看到球面的边缘很锐利。我们一直都是发射一条射线去扫描单个像素，以达到采样的目的，很明显这是不够的。为了让边缘更平滑，可以向同一个像素用更多的射线去采样。红色框表示一个像素，用更多的射线去扫描该像素，原先只是选择一个射线，扫描的是像素的中心位置进行计算，得到像素值，用它啦代替整个方框的颜色。现在就是让方框中出现有更多的点来决定方框的颜色。</p><p><img src="/pictures/RayTracing/04/1.jpg" alt="Pixel samples"></p><p>现在需要一个摄像机类来管理摄像机和场景漫游的任务。下面这个类使用之前的轴对齐相机实现了一个简单相机。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//camera.h  The camera class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">camera</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        camera() &#123;</span><br><span class="line">            <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">            <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">            origin = point3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            horizontal = vec3(viewport_width, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">            vertical = vec3(<span class="number">0.0</span>, viewport_height, <span class="number">0.0</span>);</span><br><span class="line">            lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - vec3(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="keyword">double</span> u, <span class="keyword">double</span> v)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ray(origin, lower_left_corner + u*horizontal + v*vertical - origin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        point3 origin;</span><br><span class="line">        point3 lower_left_corner;</span><br><span class="line">        vec3 horizontal;</span><br><span class="line">        vec3 vertical;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>有了camera.h就可以控制多条射线。为了处理多次采样的颜色计算，需要更新write_color()函数。在每次迭代的过程中增加全色，最后根据采样的样本数做一次除法，来写入颜色。在rtweeken.h中添加一个函数clamp(x,min,max)，将x的值限制在(min,max)中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rtweekend.h  The clamp() utility function</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">clamp</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> min, <span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; min) <span class="keyword">return</span> min;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; max) <span class="keyword">return</span> max;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//color.h The multi-sample write_color() function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_color</span><span class="params">(<span class="built_in">std</span>::ostream &amp;out, color pixel_color, <span class="keyword">int</span> samples_per_pixel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = pixel_color.x();</span><br><span class="line">    <span class="keyword">auto</span> g = pixel_color.y();</span><br><span class="line">    <span class="keyword">auto</span> b = pixel_color.z();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Divide the color by the number of samples.</span></span><br><span class="line">    <span class="keyword">auto</span> scale = <span class="number">1.0</span> / samples_per_pixel;</span><br><span class="line">    r *= scale;</span><br><span class="line">    g *= scale;</span><br><span class="line">    b *= scale;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write the translated [0,255] value of each color component.</span></span><br><span class="line">    out &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * clamp(r, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * clamp(g, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">256</span> * clamp(b, <span class="number">0.0</span>, <span class="number">0.999</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，main.c也需要修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cc Rendering with multi-sampled pixels</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Image</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// World</span></span><br><span class="line"></span><br><span class="line">    hittable_list world;</span><br><span class="line">    world.add(make_shared&lt;sphere&gt;(point3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    world.add(make_shared&lt;sphere&gt;(point3(<span class="number">0</span>,<span class="number">-100.5</span>,<span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Camera</span></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="keyword">auto</span> u = (i + random_double()) / (image_width<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + random_double()) / (image_height<span class="number">-1</span>);</span><br><span class="line">                ray r = cam.get_ray(u, v);</span><br><span class="line">                pixel_color += ray_color(r, world);</span><br><span class="line">            &#125;</span><br><span class="line">            write_color(<span class="built_in">std</span>::<span class="built_in">cout</span>, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pictures/RayTracing/04/3.png" alt="运行效果图"></p><p><img src="/pictures/RayTracing/04/4.png" alt="前后运行比较"></p><p>很明显可以看到变化，边缘不再那么锐利，边缘处的像素显得更为模糊，达到了抗锯齿的效果。</p><h4 id="8-Diffuse-Materials"><a href="#8-Diffuse-Materials" class="headerlink" title="8 Diffuse Materials"></a>8 Diffuse Materials</h4><p>我们现在已经有对象，并且每个像素都有多条光线采样。现在可以通过光线追踪制作一些逼真的材质。从漫反射材料开始。</p><h5 id="8-1-A-Simple-Diffuse-Material"><a href="#8-1-A-Simple-Diffuse-Material" class="headerlink" title="8.1  A Simple Diffuse Material"></a>8.1  A Simple Diffuse Material</h5><p>不发光的漫反射对线仅具有周围环境的颜色，但会使用其自身的固有颜色来调和这些颜色。漫反射表面反射的光是随机的。比如我们将三条光线发送到一个漫反射表面，它们反射回来的方向都是随机的。</p><p><img src="/pictures/RayTracing/04/5.jpg" alt="Light ray bounces"></p><p>它们也可能是被吸收而不是被反射。表面越暗，吸收的可能性就越大。这也是为什么它很暗。任何随机化方向的算法都会产生看起来很粗糙的表面。 最简单的方法之一是理想的漫反射表面。</p><p><img src="/pictures/RayTracing/04/6.jpg" alt="Generating a random diffuse bounce ray"></p><p>①从摄像机位置（eye）发射一条射线，交球面与p点。在p点做两个与球面相切的单位球体，这两个单位球体的球心就在<strong>P</strong>+<strong>n</strong>和<strong>P</strong>-<strong>n</strong>（其中<strong>P</strong>表示eye-&gt;p向量，<strong>n</strong>表示p点的法向量）。以<strong>P</strong>-<strong>n</strong>为球心的单位球体在表面内部，<strong>P</strong>+<strong>n</strong>在外部。选择与射线方向在同一侧的单位球体，在其中随机选择一个点s，然后将一条光线从命中点p发送到s（用向量表示为<strong>S</strong>-<strong>P</strong>）。</p><p>选择s点的方法，使用最简单的拒绝方法。在单位立方体里面选择一个随机点，其中x,y,z都控制在(-1,1)中。如果该点在单位球体之外拒绝该点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vec3.h vec3 random utility functions</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vec3</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> vec3 <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vec3(random_double(), random_double(), random_double());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> vec3 <span class="title">random</span><span class="params">(<span class="keyword">double</span> min, <span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vec3(random_double(min,max), random_double(min,max), random_double(min,max));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vec3.h The random_in_unit_sphere() function</span></span><br><span class="line"><span class="function">vec3 <span class="title">random_in_unit_sphere</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = vec3::random(<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.length_squared() &gt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新ray_color()函数来使用新的随机方向生产器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c  ray_color() using a random ray direction</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (world.hit(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        point3 target = rec.p + rec.normal + random_in_unit_sphere();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * ray_color(ray(rec.p, target - rec.p), world);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3 unit_direction = unit_vector(r.direction());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.y() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*color(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*color(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-2-Limiting-the-Number-of-Child-Rays"><a href="#8-2-Limiting-the-Number-of-Child-Rays" class="headerlink" title="8.2  Limiting the Number of Child Rays"></a>8.2  Limiting the Number of Child Rays</h5><p>ray_color()是递归的。当射线无法击中任何物体时，要停止递归。但可能会递归很长时间，直到破坏堆栈。为了防止这种事情发生，我们需要限制最大的递归深度，在最大深度不返回任何光源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c ray_color() with depth limiting</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we&#x27;ve exceeded the ray bounce limit, no more light is gathered.</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> color(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (world.hit(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        point3 target = rec.p + rec.normal + random_in_unit_sphere();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * ray_color(ray(rec.p, target - rec.p), world, depth<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3 unit_direction = unit_vector(r.direction());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.y() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*color(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*color(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Image</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> max_depth = <span class="number">50</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="keyword">auto</span> u = (i + random_double()) / (image_width<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + random_double()) / (image_height<span class="number">-1</span>);</span><br><span class="line">                ray r = cam.get_ray(u, v);</span><br><span class="line">                pixel_color += ray_color(r, world, max_depth);</span><br><span class="line">            &#125;</span><br><span class="line">            write_color(<span class="built_in">std</span>::<span class="built_in">cout</span>, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pictures/RayTracing/04/7.png" alt="运行效果图"></p>]]></content>
      
      
      <categories>
          
          <category> Ray Tracing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Ray Tracing in a Weekend》学习笔记03</title>
      <link href="2020/10/24/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003/"/>
      <url>2020/10/24/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-HZHxCBpE" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="30814948" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#3F51B5"    ></div><h5 id="6-3-An-Abstraction-for-Hittable-Objects"><a href="#6-3-An-Abstraction-for-Hittable-Objects" class="headerlink" title="6.3 An Abstraction for Hittable Objects"></a>6.3 An Abstraction for Hittable Objects</h5><p>①当视线穿过球体，肯定会有tmin和tmax。只有当tmin&lt;t&lt;tmax中间时，才算击中。在hittable.h中创建一个struct，用来记录击中的数据，</p><p>新建hittable.h：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hittable.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HITTABLE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HITTABLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"><span class="comment">//p:撞击点，normal:撞击点表面法线，t:视线公式中的系数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hit_record</span> &#123;</span></span><br><span class="line">    point3 p;</span><br><span class="line">    vec3 normal;</span><br><span class="line">    <span class="keyword">double</span> t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hittable</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>②优选选择离视线更近的结果，也就是在一元二次方程的根中选择更小的t。其实就是遮挡的问题。如果没有根说明没有碰到任何球体，返回false即可。</p><p>新建sphere.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sphere.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SPHERE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPHERE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sphere</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        sphere() &#123;&#125;</span><br><span class="line">        sphere(point3 cen, <span class="keyword">double</span> r) : center(cen), radius(r) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> tmin, <span class="keyword">double</span> tmax, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        point3 center;</span><br><span class="line">        <span class="keyword">double</span> radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sphere::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.origin() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.direction().length_squared();</span><br><span class="line">    <span class="keyword">auto</span> half_b = dot(oc, r.direction());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.length_squared() - radius*radius;</span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b*half_b - a*c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (discriminant &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> temp = (-half_b - root) / a;<span class="comment">//discriminant &gt; 0 方程两个根</span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt; t_max &amp;&amp; temp &gt; t_min) &#123;</span><br><span class="line">            rec.t = temp;</span><br><span class="line">            rec.p = r.at(rec.t);</span><br><span class="line">            rec.normal = (rec.p - center) / radius;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp = (-half_b + root) / a;<span class="comment">//discriminant &gt; 0 方程两个根</span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt; t_max &amp;&amp; temp &gt; t_min) &#123;</span><br><span class="line">            rec.t = temp;</span><br><span class="line">            rec.p = r.at(rec.t);</span><br><span class="line">            rec.normal = (rec.p - center) / radius;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h5 id="6-4-Front-Faces-Versus-Back-Faces"><a href="#6-4-Front-Faces-Versus-Back-Faces" class="headerlink" title="6.4  Front Faces Versus Back Faces"></a>6.4  Front Faces Versus Back Faces</h5><p>当法线与射线方向一致时，射线是在物体内部；当法线与射线方向相反时，射线在物体外部。正反可以通过法线与射线的点积来确定，若点积为正，则射线在物体内部，反之在外部。这样我们可以控制在正反面着色的时候呈现不同的效果（比如纸张的正反面可以写不同的字）</p><img src="/pictures/RayTracing/03/1.jpg" alt="射线与法线示意图" style="zoom:50%;" /><p>如果我们决定使法线始终指向射线，则无法使用点积来确定射线位于曲面的哪一侧。 相反，我们需要存储该信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hittable.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hit_record</span> &#123;</span></span><br><span class="line">    point3 p;</span><br><span class="line">    vec3 normal;</span><br><span class="line">    <span class="keyword">double</span> t;</span><br><span class="line">    <span class="keyword">bool</span> front_face;<span class="comment">//记录是否为正面</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_face_normal</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> vec3&amp; outward_normal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//点积小于0 ray outside 点积大于0 ray inside</span></span><br><span class="line">        front_face = dot(r.direction(), outward_normal) &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//始终让法线指向射线，即让法线和射线的点积始终小于0</span></span><br><span class="line">        normal = front_face ? outward_normal :-outward_normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，我们将确定好的表面添加到类中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sphere.h</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sphere::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.origin() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.direction().length_squared();</span><br><span class="line">    <span class="keyword">auto</span> half_b = dot(oc, r.direction());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.length_squared() - radius*radius;</span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b*half_b - a*c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (discriminant &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line">        <span class="keyword">auto</span> temp = (-half_b - root) / a;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; t_max &amp;&amp; temp &gt; t_min) &#123;</span><br><span class="line">            rec.t = temp;</span><br><span class="line">            rec.p = r.at(rec.t);</span><br><span class="line">            <span class="comment">//获取到法线</span></span><br><span class="line">            vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">            <span class="comment">//设置我们想要的表面法线，即法线始终指向射线</span></span><br><span class="line">            rec.set_face_normal(r, outward_normal);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = (-half_b + root) / a;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; t_max &amp;&amp; temp &gt; t_min) &#123;</span><br><span class="line">            rec.t = temp;</span><br><span class="line">            rec.p = r.at(rec.t);</span><br><span class="line">            <span class="comment">//获取到法线</span></span><br><span class="line">            vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">            <span class="comment">//设置我们想要的表面法线，即法线始终指向射线</span></span><br><span class="line">            rec.set_face_normal(r, outward_normal);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-5-A-List-of-Hittable-Objects"><a href="#6-5-A-List-of-Hittable-Objects" class="headerlink" title="6.5  A List of Hittable Objects"></a>6.5  A List of Hittable Objects</h5><p>新建一个类存储hittable列表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HITTABLE_LIST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HITTABLE_LIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::make_shared;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hittable_list</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        hittable_list() &#123;&#125;</span><br><span class="line">        hittable_list(<span class="built_in">shared_ptr</span>&lt;hittable&gt; object) &#123; add(object); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; objects.clear(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;hittable&gt; object)</span> </span>&#123; objects.push_back(object); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> tmin, <span class="keyword">double</span> tmax, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;hittable&gt;&gt; objects;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hittable_list::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    hit_record temp_rec;</span><br><span class="line">    <span class="keyword">bool</span> hit_anything = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> closest_so_far = t_max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; object : objects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (object-&gt;hit(r, t_min, closest_so_far, temp_rec)) &#123;</span><br><span class="line">            hit_anything = <span class="literal">true</span>;</span><br><span class="line">            closest_so_far = temp_rec.t;</span><br><span class="line">            rec = temp_rec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hit_anything;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>原文6.6介绍了shared_ptr和make_shared的一些原理和用法，不再赘述。</p><h5 id="6-7-Common-Constants-and-Utility-Functions"><a href="#6-7-Common-Constants-and-Utility-Functions" class="headerlink" title="6.7  Common Constants and Utility Functions"></a>6.7  Common Constants and Utility Functions</h5><p>新建rtweekend.h，定义一些自己需要用到的常量和未来可能使用的实用程序函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rtweekend.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RTWEEKEND_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTWEEKEND_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Usings</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::make_shared;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">sqrt</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constants</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> infinity = <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">double</span>&gt;::infinity();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.1415926535897932385</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Utility Functions</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">degrees_to_radians</span><span class="params">(<span class="keyword">double</span> degrees)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> degrees * pi / <span class="number">180.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Common Headers</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>修改main.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sphere.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">//调用hittable_list.h重写的hit函数，该函数会调用object对应的hit函数，这里就是sphere的hit函数</span></span><br><span class="line">    <span class="keyword">if</span> (world.hit(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * (rec.normal + color(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = unit_vector(r.direction());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.y() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*color(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*color(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Image</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// World</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="comment">//两个sphere</span></span><br><span class="line">    world.add(make_shared&lt;sphere&gt;(point3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    world.add(make_shared&lt;sphere&gt;(point3(<span class="number">0</span>,<span class="number">-100.5</span>,<span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Camera</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">    <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> origin = point3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> horizontal = vec3(viewport_width, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> vertical = vec3(<span class="number">0</span>, viewport_height, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - vec3(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = <span class="keyword">double</span>(i) / (image_width<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> v = <span class="keyword">double</span>(j) / (image_height<span class="number">-1</span>);</span><br><span class="line">            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u*horizontal + v*vertical)</span></span>;</span><br><span class="line">            color pixel_color = ray_color(r, world);</span><br><span class="line">            write_color(<span class="built_in">std</span>::<span class="built_in">cout</span>, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pictures/RayTracing/03/2.png" alt="运行结果"></p><p>原文第六节到此结束。</p>]]></content>
      
      
      <categories>
          
          <category> Ray Tracing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Ray Tracing in a Weekend》学习笔记02</title>
      <link href="2020/10/24/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/"/>
      <url>2020/10/24/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/</url>
      
        <content type="html"><![CDATA[<h4 id="5-Adding-a-Sphere"><a href="#5-Adding-a-Sphere" class="headerlink" title="5.   Adding a Sphere"></a><strong>5.   Adding a Sphere</strong></h4><p>让我们向光线追踪器添加一个对象。 人们通常在光线跟踪器中使用球体，因为计算射线是否撞击球体非常简单。</p><h5 id="5-1-Ray-Sphere-Intersection"><a href="#5-1-Ray-Sphere-Intersection" class="headerlink" title="5.1  Ray-Sphere Intersection"></a><strong>5.1  Ray-Sphere Intersection</strong></h5><p>当逐行扫描屏幕的所有像素点，从摄像机位置发出对应的视线，视线与球体会发生三种碰撞，一是视线不与球体相交，那屏幕上看到的还是背景颜色，二是视线与球体相切，三是视线与球体相交。我们只需推算出直线与球是否相交的公式。简单的公式推导，得出的公式：<br>$$<br>t^2b⋅b+2tb⋅(A−C)+(A−C)⋅(A−C)−r^2=0<br>$$<br>相当于求t的一元二次方程,b是光线的方向向量，A是光线的发射位置，C是球体的中心位置，r是球体半径。</p><h5 id="5-2Creating-Our-First-Raytraced-Image"><a href="#5-2Creating-Our-First-Raytraced-Image" class="headerlink" title="5.2Creating Our First Raytraced Image"></a><strong>5.2Creating Our First Raytraced Image</strong></h5><p>如果我们采用该数学并将其硬编码到我们的程序中，则可以通过将位于z轴上-1处的小球碰到的任何像素变为红色来对其进行测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hit_sphere</span><span class="params">(<span class="keyword">const</span> point3&amp; center, <span class="keyword">double</span> radius, <span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.origin() - center;<span class="comment">//oc=A-C(-号在vec3.h中重载了，所以返回的还是vec3)</span></span><br><span class="line">    <span class="keyword">auto</span> a = dot(r.direction(), r.direction());</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="number">2.0</span> * dot(oc, r.direction());<span class="comment">//b·(A-C)</span></span><br><span class="line">    <span class="keyword">auto</span> c = dot(oc, oc) - radius*radius;<span class="comment">//(A−C)⋅(A−C)-r*r</span></span><br><span class="line">    <span class="keyword">auto</span> discriminant = b*b - <span class="number">4</span>*a*c;</span><br><span class="line">    <span class="keyword">return</span> (discriminant &gt; <span class="number">0</span>);<span class="comment">//&gt;0表示一元二次方程有解，则光线与球体有交集</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hit_sphere(point3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>, r))</span><br><span class="line">        <span class="keyword">return</span> color(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//光线击中的局域，都为(1,0,0),红色</span></span><br><span class="line">    vec3 unit_direction = unit_vector(r.direction());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.y() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*color(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*color(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pictures/RayTracing/02/1.png" alt="A simple red sphere"></p><p>小总结：vec3.h的功能就是定义了三维向量，包括三维向量之间的点乘，叉乘，加减乘除等操作。颜色、距离、位置等都用vec3来表示；color.h定义了RGB的输出，把范围固定在了[0,255]中。</p><h4 id="6-Surface-Normals-and-Multiple-Objects"><a href="#6-Surface-Normals-and-Multiple-Objects" class="headerlink" title="6.Surface Normals and Multiple Objects"></a><strong>6.Surface Normals and Multiple Objects</strong></h4><h5 id="6-1Surface-Normals-and-Multiple-Objects"><a href="#6-1Surface-Normals-and-Multiple-Objects" class="headerlink" title="6.1Surface Normals and Multiple Objects"></a>6.1Surface Normals and Multiple Objects</h5><p>Surface normals（表面法线），可以帮助我们区分出背面。当视线穿过球体，穿过去交点为P，则法线向量是P-C。</p><p><img src="/pictures/RayTracing/02/2.jpg" alt="Sphere surface-normal geometry"></p><p>再结合视线公式 P(t) = a + t ·b，和<br>$$<br>t^2b⋅b+2tb⋅(A−C)+(A−C)⋅(A−C)−r^2=0<br>$$<br>①当视线与球体相交的时候，t可取两个值，分别为 t1=(-b - sqrt(b * b - 4ac))/ (2.0 * a)， t2=(-b + sqrt(b * b - 4ac))/ (2.0 * a)，t1是穿过去的交点P，t2是视线穿进球体的交点。当视线与球体相切时，t1=t2。</p><p>②得到t后，调用ray.h的at()，计算出该点的P(t)，从而法线向量等于P(t)-C，对其进行单位化得到单位法线向量。</p><p>③返回一个color类的变量，把大小控制在(0,1)</p><p>所以需要更改main.c的代码，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hit_sphere</span><span class="params">(<span class="keyword">const</span> point3&amp; center, <span class="keyword">double</span> radius, <span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.origin() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = dot(r.direction(), r.direction());</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="number">2.0</span> * dot(oc, r.direction());</span><br><span class="line">    <span class="keyword">auto</span> c = dot(oc, oc) - radius*radius;</span><br><span class="line">    <span class="keyword">auto</span> discriminant = b*b - <span class="number">4</span>*a*c;</span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (-b - <span class="built_in">sqrt</span>(discriminant) ) / (<span class="number">2.0</span>*a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = hit_sphere(point3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>, r);</span><br><span class="line">    <span class="keyword">if</span> (t &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">        vec3 N = unit_vector(r.at(t) - vec3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span>*color(N.x()+<span class="number">1</span>, N.y()+<span class="number">1</span>, N.z()+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = unit_vector(r.direction());</span><br><span class="line">    t = <span class="number">0.5</span>*(unit_direction.y() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*color(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*color(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pictures/RayTracing/02/3.png" alt="A sphere colored according to its normal vectors"></p><h5 id="6-2-Simplifying-the-Ray-Sphere-Intersection-Code"><a href="#6-2-Simplifying-the-Ray-Sphere-Intersection-Code" class="headerlink" title="6.2  Simplifying the Ray-Sphere Intersection Code"></a>6.2  Simplifying the Ray-Sphere Intersection Code</h5><p>对hit_sphere()进行优化：</p><p>①向量与自身的点乘，等于向量的长度的平方(在vec3.h中定义的length_squared()就是这个原理)</p><p>②假定b=2h，对二次方程的结果进行优化，<br>$$<br>\frac{-b \pm \sqrt{b^2 - 4ac}}{2a}<br>=\frac{-2h \pm \sqrt{(2h)^2 - 4ac}}{2a}<br>=\frac{-2h \pm 2\sqrt{h^2 - ac}}{2a}<br>=\frac{-h \pm \sqrt{h^2 - ac}}{a}<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hit_sphere</span><span class="params">(<span class="keyword">const</span> point3&amp; center, <span class="keyword">double</span> radius, <span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.origin() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.direction().length_squared();</span><br><span class="line">    <span class="keyword">auto</span> half_b = dot(oc, r.direction());<span class="comment">//b=2h，只取原来的一半</span></span><br><span class="line">    <span class="keyword">auto</span> c = oc.length_squared() - radius*radius;</span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b*half_b - a*c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (-half_b - <span class="built_in">sqrt</span>(discriminant) ) / a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Ray Tracing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随机快排</title>
      <link href="2020/10/21/%E9%9A%8F%E6%9C%BA%E5%BF%AB%E6%8E%92/"/>
      <url>2020/10/21/%E9%9A%8F%E6%9C%BA%E5%BF%AB%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<p>快排在选取主元的时候，每次都选取最右边的元素。当序列为有序时，会发现划分出来的两个子序列一个里面没有元素，而另一个则只比原来少一个元素。为了避免这种情况，引入一个随机化量来破坏这种有序状态。</p><p>在随机化的快排里面，选取a[left..right]中的随机一个元素作为主元，然后再进行划分，就可以得到一个平衡的划分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> random(x) rand()%(x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">t=a[n];</span><br><span class="line">a[n]=a[m];</span><br><span class="line">a[m]=t;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">int</span> * <span class="title">partition</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> less=L<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> more=R;</span><br><span class="line"><span class="keyword">while</span>(L&lt;more)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[L]&lt;a[R])</span><br><span class="line">swap(a,++less,L++);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[L]&gt;a[R])</span><br><span class="line">swap(a,L,--more);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[L]==a[R]) </span><br><span class="line">&#123; </span><br><span class="line">L++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(a,more,R);</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">2</span>]=&#123;less+<span class="number">1</span>,more&#125;;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L&lt;R)</span><br><span class="line">&#123;</span><br><span class="line">swap(a,random(R-L+<span class="number">1</span>),R);<span class="comment">//与经典快排不同，随机在数组中选择一个数字进行比较 </span></span><br><span class="line"><span class="keyword">int</span> *p=partition(a,L,R);</span><br><span class="line">quicksort(a,L,p[<span class="number">0</span>]<span class="number">-1</span>);</span><br><span class="line">quicksort(a,p[<span class="number">1</span>]+<span class="number">1</span>,R);</span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"> <span class="keyword">int</span> a[n];</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"> &#125;</span><br><span class="line"> quicksort(a,<span class="number">0</span>,n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>多次实验结果：</p><p><strong>10w：</strong></p><table><thead><tr><th>算法</th><th>第1次耗时</th><th>第2次耗时</th><th>第3次耗时</th><th>平均耗时</th></tr></thead><tbody><tr><td>普通快排</td><td>13ms</td><td>15ms</td><td>15ms</td><td>14.333ms</td></tr><tr><td>随机化版本快排</td><td>25ms</td><td>25ms</td><td>27ms</td><td>25.667ms</td></tr></tbody></table><p><strong>100w：</strong></p><table><thead><tr><th>算法</th><th>第1次耗时</th><th>第2次耗时</th><th>第3次耗时</th><th>平均耗时</th></tr></thead><tbody><tr><td>普通快排</td><td>101ms</td><td>103ms</td><td>96ms</td><td>100ms</td></tr><tr><td>随机化版本快排</td><td>119ms</td><td>101ms</td><td>105ms</td><td>108.333ms</td></tr></tbody></table><p><strong>1000w：</strong></p><table><thead><tr><th>算法</th><th>第1次耗时</th><th>第2次耗时</th><th>第3次耗时</th><th>平均耗时</th></tr></thead><tbody><tr><td>普通快排</td><td>1397ms</td><td>1379ms</td><td>1338ms</td><td>1371.333ms</td></tr><tr><td>随机化版本快排</td><td>1241ms</td><td>1187ms</td><td>1258ms</td><td>1228.667ms</td></tr></tbody></table><p>随机化快排因为要生成随机数，所以有一些性能损失，所以数据规模较小，数据分布均匀时普通快排还是比随机化快排要快些的，不过随着数据规模的上升，随机化快排的性能优势就展现出来了。</p><p><strong>有序序列</strong></p><p>下来才是展示快排才华的时候，假设当输入数组已经是排好序的，这两个算法的性能差距又有多少？<br>之前的数组生成代码不变，只是在调用两个算法之前，先调用一下快排将数组排序，然后将两个有序的数组作为参数传进去。</p><p><strong>10w：</strong></p><p>10w的普通快排……已经栈溢出了。</p><table><thead><tr><th>算法</th><th>第1次耗时</th><th>第2次耗时</th><th>第3次耗时</th><th>平均耗时</th></tr></thead><tbody><tr><td>普通快排</td><td>溢出</td><td>溢出</td><td>溢出</td><td>溢出</td></tr><tr><td>随机化版本快排</td><td>15ms</td><td>7ms</td><td>6ms</td><td>9.333ms</td></tr></tbody></table><p><strong>1w：</strong></p><p>试一试1w的</p><table><thead><tr><th>算法</th><th>第1次耗时</th><th>第2次耗时</th><th>第3次耗时</th><th>平均耗时</th></tr></thead><tbody><tr><td>普通快排</td><td>98ms</td><td>94ms</td><td>92ms</td><td>94.667ms</td></tr><tr><td>随机化版本快排</td><td>2ms</td><td>1ms</td><td>0ms</td><td>1ms</td></tr></tbody></table><p><strong>1000w：</strong></p><p>看下1000w下随机化快排是否有影响</p><table><thead><tr><th>算法</th><th>第1次耗时</th><th>第2次耗时</th><th>第3次耗时</th><th>平均耗时</th></tr></thead><tbody><tr><td>随机化版本快排</td><td>696ms</td><td>733ms</td><td>689ms</td><td>706ms</td></tr></tbody></table><p><em>参考书籍：机械工业出版社 第三版<strong>《算法导论》</strong>部分内容引自原书</em></p>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL学习笔记01-GLFW、GLAD、GLUT配置方法</title>
      <link href="2020/10/19/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-GLFW%E3%80%81GLAD%E3%80%81GLUT%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
      <url>2020/10/19/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-GLFW%E3%80%81GLAD%E3%80%81GLUT%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><strong>1.GLFW</strong></p><p><a href="https://www.glfw.org/download.html">https://www.glfw.org/download.html</a></p><p>进入该网站直接下载<a href="https://github.com/glfw/glfw/releases/download/3.3.2/glfw-3.3.2.bin.WIN32.zip">32-bit Windows binaries</a></p><p>ps:注意旁边的提示，vs10及以上的下载64位，其他下载32位，但通常建议都使用32位。下载好后直接解压。</p><p><img src="/pictures/OpenGL/01/1.png" alt="GLFW下载页面"></p><p><strong>2.GLAD</strong></p><p><a href="https://glad.dav1d.de/">https://glad.dav1d.de/</a></p><p><img src="/pictures/OpenGL/01/2.png" alt="GLAD下载页面"></p><p>如图所示，其中gl选择最新版的即可。选择好后，Options中勾选 Generate a loader,再点击下方GENERATE。</p><p><img src="/pictures/OpenGL/01/3.png" alt="GENERATE"></p><p><strong>3.GLEW</strong></p><p><a href="http://glew.sourceforge.net/">http://glew.sourceforge.net/</a></p><p><img src="/pictures/OpenGL/01/glew1.png" alt="glew下载"></p><p><strong>通常都是下载32位！</strong></p><p>下载后解压，此时你将得到这三个文件夹。</p><p><img src="/pictures/OpenGL/01/image-20201011191208599.png" alt="解压后的文件夹"></p><p>再新建一个文件夹（例如：OpenGL，不要是中文），新建三个子文件夹，分别为include,lib,src。</p><p>将glfw-3.3.2.bin.WIN32-&gt;include-&gt;GLFW和glew-2.1.0-&gt;include-&gt;GL复制到OpenGL-&gt;include中</p><p><img src="/pictures/OpenGL/01/image-20201011191714672.png" alt="GLFW文件路径"></p><p><img src="/pictures/OpenGL/01/glew2.png" alt="GLEW文件路径"></p><p>将glfw-3.3.2.bin.WIN32-&gt;lib-vc2019(对应你所使用的版本)-&gt;glfw3.lib和glew-2.1.0-&gt;lib-&gt;Release-&gt;Win32-&gt;glew32.lib、glew32s.lib复制到OpenGL-&gt;lib中</p><p><img src="/pictures/OpenGL/01/image-20201011191802906.png" alt="glfw3.lib文件路径"></p><p><img src="/pictures/OpenGL/01/glew3.png" alt="glew32.lib、glew32s.lib文件路径"></p><p>将glad-&gt;include下面的两个文件夹全部复制到OpenGL-&gt;include中</p><p><img src="/pictures/OpenGL/01/image-20201011191957265.png" alt="glad-&gt;iinclude路径"></p><p>将glad-&gt;src下的内容复制到OpenGL-&gt;src中</p><p><img src="/pictures/OpenGL/01/image-20201011192202606.png" alt="glad-&gt;src文件路径"></p><p>在vs中新建一个空项目</p><p><img src="/pictures/OpenGL/01/image-20201011192545752.png" alt="新建空项目"></p><p>将刚刚建好的OpenGL文件夹复制到和项目同级目录中</p><p><img src="/pictures/OpenGL/01/image-20201011192736579.png" alt="OpenGL移动位置"></p><p>右键项目选择属性，VC++目录-&gt;包含目录，将OpenGL中的include文件夹添加进来，再选择VC++目录-&gt;库目录，将OpenGL中的lib文件夹添加进来。</p><p>ps：记得选择所有配置，所有平台</p><p><img src="/pictures/OpenGL/01/image-20201011193306706.png" alt="修改包含目录"></p><p><img src="/pictures/OpenGL/01/image-20201011193226797.png" alt="修改库目录"></p><p>在链接器-&gt;输入-&gt;附加依赖项选项卡里添加<br><code>opengl32.lib</code></p><p><code>glew32s.lib</code></p><p><code>glfw3.lib</code><br><img src="/pictures/OpenGL/01/image-20201011193522438.png" alt="添加附加依赖"></p><p>填写完成后，点击应用，确定后退出。</p><p>右键源文件，添加现有项，将OpenGl-&gt;src下的glad.c文件添加进来</p><p><img src="/pictures/OpenGL/01/image-20201011193656048.png" alt="右键源文件"><br><img src="/pictures/OpenGL/01/image-20201011193712712.png" alt="添加glad.c"></p><p>一切完成后，新建一个cpp文件，跑测试代码。</p><p>vs有个小问题，就是没有添加c++文件，在属性里面是没有C/C++这栏的，再添加cpp文件后，再次打开属性页，在C/C++-&gt;常规-&gt;附件包含目录中添加OpenGL文件夹中的include文件夹，在链接器-&gt;常规-&gt;附加库目录中添加OpenGL文件夹中的lib文件夹，一切完成。</p><p>测试代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;glm/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//模型顶点数据</span></span><br><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line"><span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">/* Postion 右上角  Color*/</span>  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"><span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">/* 右下角 */</span>    <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">/* 左下角 */</span>    <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">/* 左上角*/</span><span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始! </span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* vertexShaderSource =</span><br><span class="line"><span class="string">&quot;#version 330 core                                \n&quot;</span></span><br><span class="line"><span class="string">&quot;layout(location = 0) in vec3 aPos;              \n&quot;</span></span><br><span class="line"><span class="string">&quot;layout(location = 1) in vec3 aColor;              \n&quot;</span></span><br><span class="line"><span class="string">&quot;out vec4 vertexColor;                                      \n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line"><span class="string">&quot;vertexColor = vec4(aColor.x,aColor.y,aColor.z,1.0);&#125;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* fragmentShaderSource =</span><br><span class="line"><span class="string">&quot;#version 330 core                             \n&quot;</span></span><br><span class="line"><span class="string">&quot;in vec4 vertexColor; \n&quot;</span></span><br><span class="line"><span class="string">&quot;out vec4 FragColor;                           \n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;FragColor = vertexColor;&#125;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">glfwInit();</span><br><span class="line"><span class="comment">//设置opengl版本3.3</span></span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">//告诉glfw主要版本3</span></span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//告诉glfw次要版本3</span></span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<span class="comment">//告诉glfw使用core-profile</span></span><br><span class="line"></span><br><span class="line">GLFWwindow* window = glfwCreateWindow(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Test window&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">glfwTerminate();<span class="comment">//销毁窗口，释放资源</span></span><br><span class="line"><span class="comment">//return EXIT_FAILURE;</span></span><br><span class="line">&#125;</span><br><span class="line">glfwMakeContextCurrent(window);<span class="comment">//指定线程</span></span><br><span class="line"></span><br><span class="line">glewExperimental = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (glewInit() != GLEW_OK)<span class="comment">//初始glew工具</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;glew init failed.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">glfwTerminate();</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置视口视角</span></span><br><span class="line">glViewport(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//框线模式 Wireframe Mode</span></span><br><span class="line"><span class="comment">glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span></span><br><span class="line"><span class="comment">//剔除多边形背面</span></span><br><span class="line"><span class="comment">//glEnable(GL_CULL_FACE);</span></span><br><span class="line"><span class="comment">//glCullFace(GL_FRONT);//GL_BACK:剔除背面 ，GL_FRONT:剔除正面</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//VAO 绑定Vertex Arrays</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="comment">//VBO</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">//EBO</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> EBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//编译</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(vertexShader);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(fragmentShader);</span><br><span class="line"><span class="comment">//link 程序</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">shaderProgram = glCreateProgram();</span><br><span class="line">glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">glLinkProgram(shaderProgram);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.input</span></span><br><span class="line"><span class="comment">//--------</span></span><br><span class="line">processInput(window);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.render</span></span><br><span class="line"><span class="comment">//--------</span></span><br><span class="line"><span class="comment">//设置要填充的颜色（r 0-1.0，g 0-1.0，b 0-1.0，不透明度0-1.0）</span></span><br><span class="line">glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">0.1f</span>);</span><br><span class="line"><span class="comment">//清空colorbuff的缓冲区</span></span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"><span class="comment">//--------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Draw Triangle</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line"></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line"><span class="comment">//glDrawArrays(GL_TRIANGLES, 0, 6);</span></span><br><span class="line"></span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.swap buffers and Poll IO events</span></span><br><span class="line"><span class="comment">//-------</span></span><br><span class="line">glfwSwapBuffers(window);</span><br><span class="line">glfwPollEvents();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glfwTerminate();</span><br><span class="line"><span class="comment">//std::cin.get();</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Esc按键响应程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">&#123;</span><br><span class="line">glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/pictures/OpenGL/01/image-20201011194022926.png" alt="正确运行结果"></p><p>喜大普奔！！！、安装成功！！！</p><p><strong>3.GLUT</strong></p><p><img src="/pictures/OpenGL/01/image-20201011195655178.png" alt="GLUT下载页面"></p><p><a href="https://www.opengl.org/resources/libraries/glut/">https://www.opengl.org/resources/libraries/glut/</a></p><p>从官网得知目前推荐使用freeglut。这里提供一个OpenGL库，比较方便。<a href="https://pan.baidu.com/s/1iXQTo2dBgkD8zLE8AblgqA">https://pan.baidu.com/s/1iXQTo2dBgkD8zLE8AblgqA</a> 提取码：yvtx<br>下载后解压，配置OpenGL也就是需要把这include,dll,lib三个文件夹放到安装对应的文件夹中。</p><p>按照下图路径找到对应文件夹，下图是vs2019的路径，其他版本可以自行寻找。</p><p><img src="/pictures/OpenGL/01/image-20201011200105772.png" alt="vs2019对应路径"></p><p>将解压得到的lib文件夹和include文件夹复制到图中对应的文件夹中<br>再把dll文件夹中的5个dll文件粘贴到C:\Windows\System32和C:\Windows\SysWOW64</p><p>再运行测试代码，正确结果如下图所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openGL/glut.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">glClearColor(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line"> </span><br><span class="line">glMatrixMode(GL_PROJECTION);</span><br><span class="line">gluOrtho2D(<span class="number">0.0</span>, <span class="number">200.0</span>, <span class="number">0.0</span>, <span class="number">150.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lineSegment</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">glColor3f(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">glBegin(GL_LINES);</span><br><span class="line">glVertex2i(<span class="number">180</span>, <span class="number">15</span>);</span><br><span class="line">glVertex2i(<span class="number">10</span>, <span class="number">145</span>);</span><br><span class="line">glEnd();</span><br><span class="line"> </span><br><span class="line">glFlush();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">glutInit(&amp;argc, argv);</span><br><span class="line">glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);</span><br><span class="line">glutInitWindowPosition(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">glutInitWindowSize(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">glutCreateWindow(<span class="string">&quot;Demo OpenGL Program&quot;</span>);</span><br><span class="line"> </span><br><span class="line">init();</span><br><span class="line">glutDisplayFunc(lineSegment);</span><br><span class="line">glutMainLoop();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pictures/OpenGL/01/image-20201011200310469.png" alt="正确运行结果"></p><p>ps：这里是#include &lt;openGL/glut.h&gt;，因为glut.h头文件保存在openGL文件夹中。网上有的教程的测试代码或者教学代码是#include &lt;GL/glut.h&gt;，直接复制用来跑代码要先修改。</p><p><strong>按照上述操作，你已经可以开始OpenGL学习，无论你是使用蓝宝书学习还是在<a href="https://learnopengl-cn.github.io/%E4%B8%AD%E5%AD%A6%E4%B9%A0%EF%BC%8C%E9%83%BD%E5%A4%9F%E7%94%A8%E4%BA%86%E3%80%82">https://learnopengl-cn.github.io/中学习，都够用了。</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Ray Tracing in a Weekend》学习笔记01</title>
      <link href="2020/10/18/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
      <url>2020/10/18/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
      
        <content type="html"><![CDATA[<p>一、前期准备工作</p><p>1.下载一个<a href="http://www.121down.com/soft/softview-42834.html">ppmview</a>，用来看效果图。</p><p>2.需要你会C/C++</p><p>二、学习小结</p><p>黑体标题是按原文的标题来的，简单的章节会自动跳动。</p><h4 id="2-Output-an-Image"><a href="#2-Output-an-Image" class="headerlink" title="2.Output an Image"></a><strong>2.Output an Image</strong></h4><p>介绍了一下PPM</p><p><img src="/pictures/RayTracing/01/7.png" alt="PPM"></p><p>作者给的main.c代码，运行结果就是输出一张简单的图片，运行结果见原书。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Image</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> r = <span class="keyword">double</span>(i) / (image_width<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> g = <span class="keyword">double</span>(j) / (image_height<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> b = <span class="number">0.25</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> ir = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * r);</span><br><span class="line">            <span class="keyword">int</span> ig = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * g);</span><br><span class="line">            <span class="keyword">int</span> ib = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * b);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ir &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ig &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ib &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有以下几个问题需要注意：</p><p>1.使用会auto报错。默认把auto当做声明为自动变量。（自动变量意为拥有自动的生命周期）。这是C++98的标准。可自行百度auto在c++中的使用。</p><p>解决办法：</p><p>版本：Dev-C++ 4.8.1及以上<br>找到：工具- &gt;编译选项- &gt;程序<br>对应项改为：g++ -std=c++11</p><p>2.直接运行作者的代码是看不到效果图的，通过使用 “**&gt;**” 重定向运算符来生成ppm文件(对着目录文件夹shift＋鼠标右键，选择powershell打开)，再用记事本打开ppm文件，按图示将编码改为UTF-8（这里也可以直接用notepad++修改更方便）。再将<a href="https://convertio.co/zh/txt-ppm/">txt文件转换为ppm格式</a>，就可以用PMView打开查看效果图。</p><p><img src="/pictures/RayTracing/01/2.png" alt="生成ppm文件"></p><p>记事本修改方法，较麻烦不推荐：</p><p><img src="/pictures/RayTracing/01/3.png" alt="记事本修改"></p><p>notepad++修改方法更简单：</p><p><img src="/pictures/RayTracing/01/image-20201015223955099.png" alt="notepad++修改"></p><p><img src="/pictures/RayTracing/01/4.png" alt="效果图"></p><h4 id="3-The-vec3-Class"><a href="#3-The-vec3-Class" class="headerlink" title="3.The vec3 Class"></a><strong>3.The vec3 Class</strong></h4><p>几乎所有的图形程序都有一些用于存储几何矢量和颜色的类。 在许多系统中，这些向量是4D（3D加上几何的齐次坐标，而RGB加上颜色的alpha透明通道）。 就我们的目的而言，三个坐标就足够了。 我们将对颜色，位置，方向，偏移量等使用相同的vec3类。</p><h5 id="3-1-Variables-and-Methods"><a href="#3-1-Variables-and-Methods" class="headerlink" title="3.1 Variables and Methods"></a><strong>3.1 Variables and Methods</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vec3.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> VEC3_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VEC3_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">sqrt</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vec3</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vec3() : e&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125; &#123;&#125;<span class="comment">//默认向量为(0,0,0)</span></span><br><span class="line">        vec3(<span class="keyword">double</span> e0, <span class="keyword">double</span> e1, <span class="keyword">double</span> e2) : e&#123;e0, e1, e2&#125; &#123;&#125;<span class="comment">//有初始值的向量</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">0</span>]; &#125;<span class="comment">//返回x值</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">1</span>]; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">z</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">2</span>]; &#125;</span><br><span class="line"></span><br><span class="line">        vec3 <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123; <span class="keyword">return</span> vec3(-e[<span class="number">0</span>], -e[<span class="number">1</span>], -e[<span class="number">2</span>]); &#125;<span class="comment">//重载-</span></span><br><span class="line">        <span class="keyword">double</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> e[i]; &#125;<span class="comment">//重载[]</span></span><br><span class="line">        <span class="keyword">double</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> e[i]; &#125;<span class="comment">//见注意事项</span></span><br><span class="line"></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> vec3 &amp;v) &#123;<span class="comment">//重载+=</span></span><br><span class="line">            e[<span class="number">0</span>] += v.e[<span class="number">0</span>];</span><br><span class="line">            e[<span class="number">1</span>] += v.e[<span class="number">1</span>];</span><br><span class="line">            e[<span class="number">2</span>] += v.e[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>*=(<span class="keyword">const</span> <span class="keyword">double</span> t) &#123;<span class="comment">//重载*=</span></span><br><span class="line">            e[<span class="number">0</span>] *= t;</span><br><span class="line">            e[<span class="number">1</span>] *= t;</span><br><span class="line">            e[<span class="number">2</span>] *= t;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>/=(<span class="keyword">const</span> <span class="keyword">double</span> t) &#123;<span class="comment">//重载/=</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span> *= <span class="number">1</span>/t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="comment">//返回向量长度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sqrt</span>(length_squared());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">length_squared</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e[<span class="number">0</span>]*e[<span class="number">0</span>] + e[<span class="number">1</span>]*e[<span class="number">1</span>] + e[<span class="number">2</span>]*e[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">double</span> e[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type aliases for vec3</span></span><br><span class="line"><span class="keyword">using</span> point3 = vec3;   <span class="comment">// 3D point</span></span><br><span class="line"><span class="keyword">using</span> color = vec3;    <span class="comment">// RGB color</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>注意事项：</p><p>C++中，const类型对象只能调用const成员函数，但非const类型对象对于重载了const和非const的函数，会优先调用非const函数。这也提醒我们对于确定不想改变的变量，一定要定义为const类型，防止调用了某个非const的成员函数改变了对象数据却没有发现！</p><p>一个类重载operator[] ()函数时，要重载operator[]两次，一个是const函数，一个是非const函数。const函数的返回值用按值传递，非const函数的返回值用引用。只实现一次重载，在某些情况下是会报错的。</p><h5 id="3-2-vec3-Utility-Functions"><a href="#3-2-vec3-Utility-Functions" class="headerlink" title="3.2 vec3 Utility Functions"></a><strong>3.2 vec3 Utility Functions</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vec3.h</span></span><br><span class="line"><span class="comment">// vec3 Utility Functions</span></span><br><span class="line"><span class="comment">//inline是C++关键字，在函数声明或定义中，函数返回类型前加上关键字inline，即可以把函数指定为内联函数。    这样可以解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题</span></span><br><span class="line"><span class="comment">//重载输出运算符&lt;&lt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; v.e[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载运算符+</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>+(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> vec3(u.e[<span class="number">0</span>] + v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] + v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] + v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载运算符-</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>-(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> vec3(u.e[<span class="number">0</span>] - v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] - v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] - v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载运算符*，vec*vec</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> vec3(u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载运算符*，double*vec</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">double</span> t, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> vec3(t*v.e[<span class="number">0</span>], t*v.e[<span class="number">1</span>], t*v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载运算符*，vec*double</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">const</span> vec3 &amp;v, <span class="keyword">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t * v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载运算符/，vec/double</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>/(vec3 v, <span class="keyword">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>/t) * v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义点乘函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dot</span><span class="params">(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>]</span><br><span class="line">         + u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>]</span><br><span class="line">         + u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义叉乘函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">cross</span><span class="params">(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> vec3(u.e[<span class="number">1</span>] * v.e[<span class="number">2</span>] - u.e[<span class="number">2</span>] * v.e[<span class="number">1</span>],</span><br><span class="line">                u.e[<span class="number">2</span>] * v.e[<span class="number">0</span>] - u.e[<span class="number">0</span>] * v.e[<span class="number">2</span>],</span><br><span class="line">                u.e[<span class="number">0</span>] * v.e[<span class="number">1</span>] - u.e[<span class="number">1</span>] * v.e[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义转换单位向量函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">unit_vector</span><span class="params">(vec3 v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v / v.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-Color-Utility-Functions"><a href="#3-3-Color-Utility-Functions" class="headerlink" title="3.3  Color Utility Functions"></a><strong>3.3  Color Utility Functions</strong></h5><p>pixel_color的x,y,z大小都控制在（0,1），所以要转成RGB颜色，得乘上255.99。</p><p>新建一个color.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//color.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COLOR_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_color</span><span class="params">(<span class="built_in">std</span>::ostream &amp;out, color pixel_color)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Write the translated [0,255] value of each color component.</span></span><br><span class="line">    <span class="comment">//编写每个颜色分量的转换后的[0,255]值。</span></span><br><span class="line">    out &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * pixel_color.x()) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * pixel_color.y()) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * pixel_color.z()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>现在main.c函数就要改成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Image</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="comment">//把image的所有像素调用write_color</span></span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="keyword">double</span>(i)/(image_width<span class="number">-1</span>), <span class="keyword">double</span>(j)/(image_height<span class="number">-1</span>), <span class="number">0.25</span>)</span></span>;</span><br><span class="line">            write_color(<span class="built_in">std</span>::<span class="built_in">cout</span>, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Rays-a-Simple-Camera-and-Background"><a href="#4-Rays-a-Simple-Camera-and-Background" class="headerlink" title="4.   Rays, a Simple Camera, and Background"></a><strong>4.   Rays, a Simple Camera, and Background</strong></h4><h5 id="4-1-The-ray-Class"><a href="#4-1-The-ray-Class" class="headerlink" title="4.1  The ray Class"></a><strong>4.1  The ray Class</strong></h5><p>视线公式 P(t) = a + t ·b</p><p>新建ray.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ray.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ray</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ray() &#123;&#125;</span><br><span class="line">        ray(<span class="keyword">const</span> point3&amp; origin, <span class="keyword">const</span> vec3&amp; direction)</span><br><span class="line">            : orig(origin), dir(direction)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">point3 <span class="title">origin</span><span class="params">()</span> <span class="keyword">const</span>  </span>&#123; <span class="keyword">return</span> orig; &#125;</span><br><span class="line">        <span class="function">vec3 <span class="title">direction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> dir; &#125; </span><br><span class="line">        <span class="comment">//P（t）= A + tb</span></span><br><span class="line">        <span class="function">point3 <span class="title">at</span><span class="params">(<span class="keyword">double</span> t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> orig + t*dir;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        point3 orig;</span><br><span class="line">        vec3 dir;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h5 id="4-2-Sending-Rays-Into-the-Scene"><a href="#4-2-Sending-Rays-Into-the-Scene" class="headerlink" title="4.2  Sending Rays Into the Scene"></a><strong>4.2  Sending Rays Into the Scene</strong></h5><p>Now we are ready to turn the corner and make a ray tracer. <strong>At the core</strong>, the ray tracer sends rays through pixels and computes the color seen in the direction of those rays. The involved steps are <strong>(1) calculate the ray from the eye to the pixel, (2) determine which objects the ray intersects, and (3) compute a color for that intersection point.</strong></p><p>本文的项目是使用的是16:9的宽高比，坐标(0,0,0)放置的是摄像机位置（眼睛），四个蓝点确定屏幕。</p><p><img src="/pictures/RayTracing/01/fig-1.03-cam-geom.jpg" alt="坐标系示意图"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    vec3 unit_direction = unit_vector(r.direction());<span class="comment">//获得r的单位方向向量</span></span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.y() + <span class="number">1.0</span>);<span class="comment">//使得 0&lt;t&lt;1</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*color(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*color(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Image</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">//保证宽高比为16:9</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Camera</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;<span class="comment">//屏幕高度</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;<span class="comment">//屏幕宽度</span></span><br><span class="line">    <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;<span class="comment">//视距</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> origin = point3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//摄像机位置</span></span><br><span class="line">    <span class="keyword">auto</span> horizontal = vec3(viewport_width, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//屏幕水平方向最远点</span></span><br><span class="line">    <span class="keyword">auto</span> vertical = vec3(<span class="number">0</span>, viewport_height, <span class="number">0</span>);<span class="comment">//屏幕垂直方向最高点</span></span><br><span class="line">    <span class="comment">//lower_left_corner获得屏幕左下角的位置</span></span><br><span class="line">    <span class="keyword">auto</span> lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - vec3(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = <span class="keyword">double</span>(i) / (image_width<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> v = <span class="keyword">double</span>(j) / (image_height<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//从左下角开始，从下往上，从左向右，一行一行遍历</span></span><br><span class="line">            <span class="comment">//lower_left_corner + u*horizontal + v*vertical - origin  视线方向向量</span></span><br><span class="line">            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u*horizontal + v*vertical - origin)</span></span>;</span><br><span class="line">            color pixel_color = ray_color(r);</span><br><span class="line">            write_color(<span class="built_in">std</span>::<span class="built_in">cout</span>, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps:在将射线方向缩放到单位长度（因此-1.0 &lt;y &lt;1.0）之后，ray_color（ray）函数根据y坐标的高度线性混合白色和蓝色。 因为我们是在对向量进行归一化之后查看y高度，所以除了垂直渐变之外，您还会注意到颜色的水平渐变。<br>       然后，做了一个标准的图形技巧，将其缩放到0.0≤t≤1.0。 当t = 1.0时我想要蓝色。 当t = 0.0时我想要白色。 在这两者之间，我要混合。 这在两件事之间形成“线性混合”或“线性插值”或简称“ lerp”。  lerp总是形式<br>$$<br>blendedValue=(1−t)⋅startValue+t⋅endValue<br>$$<br>①确定分辨率，设定宽度image_width，通过宽高比算出高度image_width。相当于确定像素数量</p><p>②确定开始位置lower_left_corner，从viewport左下角开始计算，自下而上，自左向右，按行遍历。</p><p>③确定分辨率下的位置。lower_left_corner + u + v </p><p>④映射。要将分辨率下的位置转换到屏幕的屏幕坐标。例如分辨下的水平长度x=100。先将n=100/image_width-1，得到0&lt;n&lt;1，再将n * horizontal，就得到屏幕上的长度。lower_left_corner + u*horizontal + v *vertical</p><p>⑤最后再减去摄像机的位置，即可得到视线方向向量。</p><p>ray_color（const ray＆r）：将视线向量进行单位化，算出r的单位向量，将该向量的y，控制在（0,1）之间，通过线性差值的方法，使得图像出现渐变色。</p><p>write_color(std::ostream &amp;out, color pixel_color) ：pixel_color.x()乘255.999的目的就是把输出值控制在[0,255]之间，因为pixel_color.x()是在(0,1)之间。</p><p><img src="/pictures/RayTracing/01/image-20201016112514547.png" alt="效果图"></p><p>小总结：从viewport左下角开始计算，自下而上，自左向右，按行遍历像素。调用ray_color，计算光线在该像素的pixel_color。再调用write_color记录下该像素点的RGB。</p>]]></content>
      
      
      <categories>
          
          <category> Ray Tracing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="2020/10/12/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>2020/10/12/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-LVmQfvkK" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1481164987" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#3F51B5"    ></div><p>堆是一种数据结构，一种叫做完全二叉树的数据结构。</p><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p><p>大顶堆：a[i] &gt;=a[2i+1] &amp;&amp; ar[i] &gt;= a[2i+2]  </p><p>小顶堆：a[i] &lt;= a[2i+1] &amp;&amp; a[i] &lt;= a[2i+2]  </p><p><strong>堆排序的基本思想：</strong></p><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p><p>算法思想：</p><p>1.把一组数据a[n]调整成大根堆或小根堆,用heapSize来实时记录数组尚未排序的数据的数量，初始值为a[n]长度n</p><p>2.将a[0]与a[–heapSize]交换值，因为一开始就把数据调整为大根堆，该步骤相当于把已经找出数组中最大的数据，并放到了最后一位，不再处理。</p><p>3.a[0]与a[–heapSize]交换值后，也破坏了大根堆，但除了a[0]以外，数组其他数据还是保持大根堆状态。此时就是一直将a[0]数据“下沉”，让他不断和孩子节点比较，直到找到孩子节点都比它小，停止“下沉”，被破坏了的大根堆又重新被调整为大根堆。不断–heapSize，不断调整大根堆，每次都把a[0]与a[–heapSize]交换值，最终数组有序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">t=a[n];</span><br><span class="line">a[n]=a[m];</span><br><span class="line">a[m]=t;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> index,<span class="keyword">int</span> heapsize)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span>(left&lt;heapsize)<span class="comment">//判断左孩子是否越界，若越界说明左孩子已经到达最下面 </span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">//比较两个孩子谁的值大 ，谁的值大谁就是largest </span></span><br><span class="line"> <span class="keyword">int</span> largest=left+<span class="number">1</span>&lt;heapsize&amp;&amp;a[left+<span class="number">1</span>]&gt;a[left]?left+<span class="number">1</span>:left;</span><br><span class="line"> <span class="comment">//比较父节点和孩子节点的大小</span></span><br><span class="line"> largest=a[largest]&gt;a[index]?largest:index; </span><br><span class="line"> <span class="keyword">if</span>(largest==index)<span class="comment">//若发现孩子节点都比a[index]小，则循环结束</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> swap(a,largest,index);</span><br><span class="line"> index=largest;</span><br><span class="line"> left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> index)</span><span class="comment">//把数组调成大根堆 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(a[index]&gt;a[(index<span class="number">-1</span>)/<span class="number">2</span>])</span><br><span class="line">&#123;</span><br><span class="line">swap(a,index,(index<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">index=(index<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="literal">NULL</span>||n&lt;<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">heapInsert(a,i);</span><br><span class="line"><span class="keyword">int</span> heapSize=n;</span><br><span class="line">swap(a,<span class="number">0</span>,--heapSize);<span class="comment">//交换后大根堆的最大的值到数组最后一个位置 </span></span><br><span class="line"><span class="keyword">while</span>(heapSize&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//每次都把数组中0-heapSize调整成大根堆 </span></span><br><span class="line">heapify(a,<span class="number">0</span>,heapSize);</span><br><span class="line">swap(a,<span class="number">0</span>,--heapSize);</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"> <span class="keyword">int</span> a[n];</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"> &#125;</span><br><span class="line"> heapSort(a,n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>荷兰国旗</title>
      <link href="2020/10/10/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97/"/>
      <url>2020/10/10/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数数组，给定一个值K，这个值在原数组中一定存在，要求把数组中小于K的元素放到数组的左边，大于K的元素放到数组的右边，等于K的元素放到数组的中间，最终返回一个整数数组，其中只有两个值，分别是等于K的数组部分的左右两个下标值。</p><p>例如，给定数组：[2, 3, 1, 9, 7, 6, 1, 4, 5]，给定一个值4，那么经过处理原数组可能得一种情况是：[2, 3, 1, 1, 4, 9, 7, 6, 5]， 需要注意的是，小于4的部分不需要有序，大于4的部分也不需要有序，返回等于4部分的左右两个下标，即[4, 4]</p><p>解析：有一点快排的思想。把数组分成三个区域，分别是less，equal，more。一直都是less区域推着equal区域挤压more区域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span><span class="comment">//交换数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">t=a[n];</span><br><span class="line">a[n]=a[m];</span><br><span class="line">a[m]=t;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> less=L<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> more=R+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(L&lt;more)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//L一直都是指向正在进行比较的数字 </span></span><br><span class="line"><span class="keyword">if</span>(a[L]&lt;num)<span class="comment">//如果小于num，less区域就要向右扩大，less++和L进行交换 </span></span><br><span class="line">swap(a,++less,L++);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[L]&gt;num)<span class="comment">//如果小于num，more区域就要向左扩大，--more和L进行交换 </span></span><br><span class="line">swap(a,L,--more);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[L]==num)<span class="comment">//如果等于num，则直接把L++，这样即可保证相等区域一直没有变动。 </span></span><br><span class="line">&#123; </span><br><span class="line">L++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n,num;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;num;</span><br><span class="line"> <span class="keyword">int</span> a[n];</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"> &#125;</span><br><span class="line"> partition(a,<span class="number">0</span>,n<span class="number">-1</span>,num);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆序对</title>
      <link href="2020/10/09/%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
      <url>2020/10/09/%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://www.nowcoder.com/questionTerminal/f50f89c3b4624cd6aa3312747cd45879">https://www.nowcoder.com/questionTerminal/f50f89c3b4624cd6aa3312747cd45879</a><br>来源：牛客网</p><p>给定一个长度为n的排列A,逆序的定义：(i,j)为逆序对，当i&lt;j &amp;&amp; A[i]&gt;A[j] </p><p>  求排列A的逆序对数量。 </p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行一个整数n，表示排列的长度.</span><br><span class="line">第二行n个元素，表示A排列.</span><br></pre></td></tr></table></figure><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出逆序对的数量</span><br></pre></td></tr></table></figure><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 2 4 1 5</span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>解析：原理是归并排序，在每次merge之前，比较左右两边的大小，若出现当i&lt;j &amp;&amp; A[i]&gt;A[j] ，则逆序对数量加一。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> L,<span class="keyword">int</span> mid,<span class="keyword">int</span> R)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> a[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;mergeSort(a,n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="literal">NULL</span>||n&lt;<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> sortProcess(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L&gt;=R)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid=L+((R-L)&gt;&gt;<span class="number">1</span>);<span class="comment">//相当于(L+R)/2,可有效避免溢出 </span></span><br><span class="line"><span class="keyword">return</span>sortProcess(a,L,mid)+sortProcess(a,mid+<span class="number">1</span>,R)+merge(a,L,mid,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> L,<span class="keyword">int</span> mid,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> help[R-L+<span class="number">1</span>];<span class="comment">//保存每次merge后的数组 </span></span><br><span class="line"><span class="built_in">memset</span>(help, <span class="number">0</span>, <span class="keyword">sizeof</span>(help));</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> p1=L;</span><br><span class="line"><span class="keyword">int</span> p2=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> rul=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p1&lt;=mid&amp;&amp;p2&lt;=R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//设任意p1&lt;m&lt;mid,当a[p1]&gt;a[p2]时，a[m]&lt;a[p2]也显然成立，m的数量为 mid-p1+1</span></span><br><span class="line"><span class="comment">//rul+=a[p1]&lt;=a[p2]?(R-p2+1)*a[p1]:0;</span></span><br><span class="line">rul+=a[p1]&gt;a[p2]?(mid-p1+<span class="number">1</span>):<span class="number">0</span>;</span><br><span class="line">help[i++]=a[p1]&lt;=a[p2]?a[p1++]:a[p2++];<span class="comment">//每次选择小的数字存入数组 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左右两边的数量不是每次都相等，将剩下的元素也添加到help数组中 </span></span><br><span class="line"><span class="keyword">while</span>(p1&lt;=mid)</span><br><span class="line">&#123;</span><br><span class="line">help[i++]=a[p1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(p2&lt;=R)</span><br><span class="line">&#123;</span><br><span class="line">help[i++]=a[p2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;R-L+<span class="number">1</span>;i++)</span><br><span class="line">a[L+i]=help[i];</span><br><span class="line"><span class="keyword">return</span> rul;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组小和</title>
      <link href="2020/10/08/%E6%95%B0%E7%BB%84%E5%B0%8F%E5%92%8C/"/>
      <url>2020/10/08/%E6%95%B0%E7%BB%84%E5%B0%8F%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://www.nowcoder.com/questionTerminal/edfe05a1d45c4ea89101d936cac32469">https://www.nowcoder.com/questionTerminal/edfe05a1d45c4ea89101d936cac32469</a><br>来源：牛客网</p><p>数组小和的定义如下： </p><p>  例如，数组s = [1, 3, 5, 2, 4, 6]，在s[0]的左边小于或等于s[0]的数的和为0；在s[1]的左边小于或等于s[1]的数的和为1；在s[2]的左边小于或等于s[2]的数的和为1+3=4；在s[3]的左边小于或等于s[3]的数的和为1； </p><p>  在s[4]的左边小于或等于s[4]的数的和为1+3+2=6；在s[5]的左边小于或等于s[5]的数的和为1+3+5+2+4=15。所以s的小和为0+1+4+1+6+15=27 </p><p>  给定一个数组s，实现函数返回s的小和 </p><p>   [要求]  </p><p>   时间复杂度为O(nlogn)，空间复杂度为O(n)  </p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行有一个整数N。表示数组长度</span><br><span class="line">接下来一行N个整数表示数组内的数</span><br></pre></td></tr></table></figure><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个整数表示答案</span><br></pre></td></tr></table></figure><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">1 3 5 2 4 6</span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">27</span><br></pre></td></tr></table></figure><h5 id="备注"><a href="#备注" class="headerlink" title="备注:"></a><strong>备注:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1⩽N⩽10^5</span><br><span class="line">−100⩽arri⩽100</span><br></pre></td></tr></table></figure><p>解：本质上是归并排序问题，只是在每次排序之前先检查出左边比右边小的数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> L,<span class="keyword">int</span> mid,<span class="keyword">int</span> R)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> a[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;mergeSort(a,n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="literal">NULL</span>||n&lt;<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> sortProcess(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L&gt;=R)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid=L+((R-L)&gt;&gt;<span class="number">1</span>);<span class="comment">//相当于(L+R)/2,可有效避免溢出 </span></span><br><span class="line"><span class="keyword">return</span>sortProcess(a,L,mid)+sortProcess(a,mid+<span class="number">1</span>,R)+merge(a,L,mid,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> L,<span class="keyword">int</span> mid,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> help[R-L+<span class="number">1</span>];<span class="comment">//保存每次merge后的数组 </span></span><br><span class="line"><span class="built_in">memset</span>(help, <span class="number">0</span>, <span class="keyword">sizeof</span>(help));</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> p1=L;</span><br><span class="line"><span class="keyword">int</span> p2=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> rul=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p1&lt;=mid&amp;&amp;p2&lt;=R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//设任意p2&lt;m&lt;R,当a[p1]&lt;=a[p2]时，a[p1]&lt;a[m]也显然成立，m的数量为 R-p2+1</span></span><br><span class="line">rul+=a[p1]&lt;=a[p2]?(R-p2+<span class="number">1</span>)*a[p1]:<span class="number">0</span>;</span><br><span class="line">help[i++]=a[p1]&lt;=a[p2]?a[p1++]:a[p2++];<span class="comment">//每次选择小的数字存入数组 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左右两边的数量不是每次都相等，将剩下的元素也添加到help数组中 </span></span><br><span class="line"><span class="keyword">while</span>(p1&lt;=mid)</span><br><span class="line">&#123;</span><br><span class="line">help[i++]=a[p1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(p2&lt;=R)</span><br><span class="line">&#123;</span><br><span class="line">help[i++]=a[p2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;R-L+<span class="number">1</span>;i++)</span><br><span class="line">a[L+i]=help[i];</span><br><span class="line"><span class="keyword">return</span> rul;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
