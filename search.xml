<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《Ray Tracing in a Weekend》学习笔记04</title>
      <link href="2020/10/28/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004/"/>
      <url>2020/10/28/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-sxJLmwiA" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1487528112" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#3F51B5"    ></div><h4 id="7-Antialiasing"><a href="#7-Antialiasing" class="headerlink" title="7.  Antialiasing"></a>7.  Antialiasing</h4><p>这章要解决边缘锯齿的问题。</p><h5 id="7-2-Some-Random-Number-Utilities"><a href="#7-2-Some-Random-Number-Utilities" class="headerlink" title="7.2 Some Random Number Utilities"></a>7.2 Some Random Number Utilities</h5><p>首先需要的是一个返回真实随机数的随机数生成器。制作一个返回规范随机数的函数，该函数通常会返回0&lt;=r&lt;1范围内的随机实数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rtweekend.h  random_double() functions</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">random_double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Returns a random real in [0,1).</span></span><br><span class="line">    <span class="keyword">return</span> rand() / (RAND_MAX + <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">random_double</span><span class="params">(<span class="keyword">double</span> min, <span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Returns a random real in [min,max).</span></span><br><span class="line">    <span class="keyword">return</span> min + (max-min)*random_double();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C ++传统上没有标准的随机数生成器，但是较新版本的C ++已使用<random>标头解决了此问题。 如果要使用此函数，则可以按照以下条件获得随机数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rtweekend.h random_double(), alternate implemenation</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">random_double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mt19937 generator;</span><br><span class="line">    <span class="keyword">return</span> distribution(generator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-2-Generating-Pixels-with-Multiple-Samples"><a href="#7-2-Generating-Pixels-with-Multiple-Samples" class="headerlink" title="7.2  Generating Pixels with Multiple Samples"></a>7.2  Generating Pixels with Multiple Samples</h5>]]></content>
      
      
      <categories>
          
          <category> Ray Tracing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Ray Tracing in a Weekend》学习笔记03</title>
      <link href="2020/10/24/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003/"/>
      <url>2020/10/24/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-ttutMXsT" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="30814948" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#3F51B5"    ></div><h5 id="6-3-An-Abstraction-for-Hittable-Objects"><a href="#6-3-An-Abstraction-for-Hittable-Objects" class="headerlink" title="6.3 An Abstraction for Hittable Objects"></a>6.3 An Abstraction for Hittable Objects</h5><p>①当视线穿过球体，肯定会有tmin和tmax。只有当tmin&lt;t&lt;tmax中间时，才算击中。在hittable.h中创建一个struct，用来记录击中的数据，</p><p>新建hittable.h：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hittable.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HITTABLE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HITTABLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"><span class="comment">//p:撞击点，normal:撞击点表面法线，t:视线公式中的系数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hit_record</span> &#123;</span></span><br><span class="line">    point3 p;</span><br><span class="line">    vec3 normal;</span><br><span class="line">    <span class="keyword">double</span> t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hittable</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>②优选选择离视线更近的结果，也就是在一元二次方程的根中选择更小的t。其实就是遮挡的问题。如果没有根说明没有碰到任何球体，返回false即可。</p><p>新建sphere.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sphere.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SPHERE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPHERE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sphere</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        sphere() &#123;&#125;</span><br><span class="line">        sphere(point3 cen, <span class="keyword">double</span> r) : center(cen), radius(r) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> tmin, <span class="keyword">double</span> tmax, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        point3 center;</span><br><span class="line">        <span class="keyword">double</span> radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sphere::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.origin() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.direction().length_squared();</span><br><span class="line">    <span class="keyword">auto</span> half_b = dot(oc, r.direction());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.length_squared() - radius*radius;</span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b*half_b - a*c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (discriminant &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> temp = (-half_b - root) / a;<span class="comment">//discriminant &gt; 0 方程两个根</span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt; t_max &amp;&amp; temp &gt; t_min) &#123;</span><br><span class="line">            rec.t = temp;</span><br><span class="line">            rec.p = r.at(rec.t);</span><br><span class="line">            rec.normal = (rec.p - center) / radius;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp = (-half_b + root) / a;<span class="comment">//discriminant &gt; 0 方程两个根</span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt; t_max &amp;&amp; temp &gt; t_min) &#123;</span><br><span class="line">            rec.t = temp;</span><br><span class="line">            rec.p = r.at(rec.t);</span><br><span class="line">            rec.normal = (rec.p - center) / radius;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h5 id="6-4-Front-Faces-Versus-Back-Faces"><a href="#6-4-Front-Faces-Versus-Back-Faces" class="headerlink" title="6.4  Front Faces Versus Back Faces"></a>6.4  Front Faces Versus Back Faces</h5><p>当法线与射线方向一致时，射线是在物体内部；当法线与射线方向相反时，射线在物体外部。正反可以通过法线与射线的点积来确定，若点积为正，则射线在物体内部，反之在外部。这样我们可以控制在正反面着色的时候呈现不同的效果（比如纸张的正反面可以写不同的字）</p><img src="/pictures/RayTracing/03/1.jpg" alt="射线与法线示意图" style="zoom:50%;" /><p>如果我们决定使法线始终指向射线，则无法使用点积来确定射线位于曲面的哪一侧。 相反，我们需要存储该信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hittable.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hit_record</span> &#123;</span></span><br><span class="line">    point3 p;</span><br><span class="line">    vec3 normal;</span><br><span class="line">    <span class="keyword">double</span> t;</span><br><span class="line">    <span class="keyword">bool</span> front_face;<span class="comment">//记录是否为正面</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_face_normal</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> vec3&amp; outward_normal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//点积小于0 ray outside 点积大于0 ray inside</span></span><br><span class="line">        front_face = dot(r.direction(), outward_normal) &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//始终让法线指向射线，即让法线和射线的点积始终小于0</span></span><br><span class="line">        normal = front_face ? outward_normal :-outward_normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，我们将确定好的表面添加到类中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sphere.h</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sphere::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.origin() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.direction().length_squared();</span><br><span class="line">    <span class="keyword">auto</span> half_b = dot(oc, r.direction());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.length_squared() - radius*radius;</span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b*half_b - a*c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (discriminant &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line">        <span class="keyword">auto</span> temp = (-half_b - root) / a;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; t_max &amp;&amp; temp &gt; t_min) &#123;</span><br><span class="line">            rec.t = temp;</span><br><span class="line">            rec.p = r.at(rec.t);</span><br><span class="line">            <span class="comment">//获取到法线</span></span><br><span class="line">            vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">            <span class="comment">//设置我们想要的表面法线，即法线始终指向射线</span></span><br><span class="line">            rec.set_face_normal(r, outward_normal);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = (-half_b + root) / a;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; t_max &amp;&amp; temp &gt; t_min) &#123;</span><br><span class="line">            rec.t = temp;</span><br><span class="line">            rec.p = r.at(rec.t);</span><br><span class="line">            <span class="comment">//获取到法线</span></span><br><span class="line">            vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">            <span class="comment">//设置我们想要的表面法线，即法线始终指向射线</span></span><br><span class="line">            rec.set_face_normal(r, outward_normal);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-5-A-List-of-Hittable-Objects"><a href="#6-5-A-List-of-Hittable-Objects" class="headerlink" title="6.5  A List of Hittable Objects"></a>6.5  A List of Hittable Objects</h5><p>新建一个类存储hittable列表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HITTABLE_LIST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HITTABLE_LIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::make_shared;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hittable_list</span> :</span> <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        hittable_list() &#123;&#125;</span><br><span class="line">        hittable_list(<span class="built_in">shared_ptr</span>&lt;hittable&gt; object) &#123; add(object); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; objects.clear(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;hittable&gt; object)</span> </span>&#123; objects.push_back(object); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> tmin, <span class="keyword">double</span> tmax, hit_record&amp; rec)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;hittable&gt;&gt; objects;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hittable_list::hit</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">double</span> t_min, <span class="keyword">double</span> t_max, hit_record&amp; rec)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    hit_record temp_rec;</span><br><span class="line">    <span class="keyword">bool</span> hit_anything = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> closest_so_far = t_max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; object : objects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (object-&gt;hit(r, t_min, closest_so_far, temp_rec)) &#123;</span><br><span class="line">            hit_anything = <span class="literal">true</span>;</span><br><span class="line">            closest_so_far = temp_rec.t;</span><br><span class="line">            rec = temp_rec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hit_anything;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>原文6.6介绍了shared_ptr和make_shared的一些原理和用法，不再赘述。</p><h5 id="6-7-Common-Constants-and-Utility-Functions"><a href="#6-7-Common-Constants-and-Utility-Functions" class="headerlink" title="6.7  Common Constants and Utility Functions"></a>6.7  Common Constants and Utility Functions</h5><p>新建rtweekend.h，定义一些自己需要用到的常量和未来可能使用的实用程序函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rtweekend.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RTWEEKEND_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTWEEKEND_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Usings</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::make_shared;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">sqrt</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constants</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> infinity = <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">double</span>&gt;::infinity();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.1415926535897932385</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Utility Functions</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">degrees_to_radians</span><span class="params">(<span class="keyword">double</span> degrees)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> degrees * pi / <span class="number">180.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Common Headers</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>修改main.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rtweekend.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sphere.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, <span class="keyword">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">//调用hittable_list.h重写的hit函数，该函数会调用object对应的hit函数，这里就是sphere的hit函数</span></span><br><span class="line">    <span class="keyword">if</span> (world.hit(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * (rec.normal + color(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = unit_vector(r.direction());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.y() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*color(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*color(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Image</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// World</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="comment">//两个sphere</span></span><br><span class="line">    world.add(make_shared&lt;sphere&gt;(point3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    world.add(make_shared&lt;sphere&gt;(point3(<span class="number">0</span>,<span class="number">-100.5</span>,<span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Camera</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">    <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> origin = point3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> horizontal = vec3(viewport_width, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> vertical = vec3(<span class="number">0</span>, viewport_height, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - vec3(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = <span class="keyword">double</span>(i) / (image_width<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> v = <span class="keyword">double</span>(j) / (image_height<span class="number">-1</span>);</span><br><span class="line">            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u*horizontal + v*vertical)</span></span>;</span><br><span class="line">            color pixel_color = ray_color(r, world);</span><br><span class="line">            write_color(<span class="built_in">std</span>::<span class="built_in">cout</span>, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pictures/RayTracing/03/2.png" alt="运行结果"></p><p>原文第六节到此结束。</p>]]></content>
      
      
      <categories>
          
          <category> Ray Tracing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Ray Tracing in a Weekend》学习笔记02</title>
      <link href="2020/10/24/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/"/>
      <url>2020/10/24/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/</url>
      
        <content type="html"><![CDATA[<h4 id="5-Adding-a-Sphere"><a href="#5-Adding-a-Sphere" class="headerlink" title="5.   Adding a Sphere"></a><strong>5.   Adding a Sphere</strong></h4><p>让我们向光线追踪器添加一个对象。 人们通常在光线跟踪器中使用球体，因为计算射线是否撞击球体非常简单。</p><h5 id="5-1-Ray-Sphere-Intersection"><a href="#5-1-Ray-Sphere-Intersection" class="headerlink" title="5.1  Ray-Sphere Intersection"></a><strong>5.1  Ray-Sphere Intersection</strong></h5><p>当逐行扫描屏幕的所有像素点，从摄像机位置发出对应的视线，视线与球体会发生三种碰撞，一是视线不与球体相交，那屏幕上看到的还是背景颜色，二是视线与球体相切，三是视线与球体相交。我们只需推算出直线与球是否相交的公式。简单的公式推导，得出的公式：<br>$$<br>t^2b⋅b+2tb⋅(A−C)+(A−C)⋅(A−C)−r^2=0<br>$$<br>相当于求t的一元二次方程,b是光线的方向向量，A是光线的发射位置，C是球体的中心位置，r是球体半径。</p><h5 id="5-2Creating-Our-First-Raytraced-Image"><a href="#5-2Creating-Our-First-Raytraced-Image" class="headerlink" title="5.2Creating Our First Raytraced Image"></a><strong>5.2Creating Our First Raytraced Image</strong></h5><p>如果我们采用该数学并将其硬编码到我们的程序中，则可以通过将位于z轴上-1处的小球碰到的任何像素变为红色来对其进行测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hit_sphere</span><span class="params">(<span class="keyword">const</span> point3&amp; center, <span class="keyword">double</span> radius, <span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.origin() - center;<span class="comment">//oc=A-C(-号在vec3.h中重载了，所以返回的还是vec3)</span></span><br><span class="line">    <span class="keyword">auto</span> a = dot(r.direction(), r.direction());</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="number">2.0</span> * dot(oc, r.direction());<span class="comment">//b·(A-C)</span></span><br><span class="line">    <span class="keyword">auto</span> c = dot(oc, oc) - radius*radius;<span class="comment">//(A−C)⋅(A−C)-r*r</span></span><br><span class="line">    <span class="keyword">auto</span> discriminant = b*b - <span class="number">4</span>*a*c;</span><br><span class="line">    <span class="keyword">return</span> (discriminant &gt; <span class="number">0</span>);<span class="comment">//&gt;0表示一元二次方程有解，则光线与球体有交集</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hit_sphere(point3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>, r))</span><br><span class="line">        <span class="keyword">return</span> color(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//光线击中的局域，都为(1,0,0),红色</span></span><br><span class="line">    vec3 unit_direction = unit_vector(r.direction());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.y() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*color(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*color(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pictures/RayTracing/02/1.png" alt="A simple red sphere"></p><p>小总结：vec3.h的功能就是定义了三维向量，包括三维向量之间的点乘，叉乘，加减乘除等操作。颜色、距离、位置等都用vec3来表示；color.h定义了RGB的输出，把范围固定在了[0,255]中。</p><h4 id="6-Surface-Normals-and-Multiple-Objects"><a href="#6-Surface-Normals-and-Multiple-Objects" class="headerlink" title="6.Surface Normals and Multiple Objects"></a><strong>6.Surface Normals and Multiple Objects</strong></h4><h5 id="6-1Surface-Normals-and-Multiple-Objects"><a href="#6-1Surface-Normals-and-Multiple-Objects" class="headerlink" title="6.1Surface Normals and Multiple Objects"></a>6.1Surface Normals and Multiple Objects</h5><p>Surface normals（表面法线），可以帮助我们区分出背面。当视线穿过球体，穿过去交点为P，则法线向量是P-C。</p><p><img src="/pictures/RayTracing/02/2.jpg" alt="Sphere surface-normal geometry"></p><p>再结合视线公式 P(t) = a + t ·b，和<br>$$<br>t^2b⋅b+2tb⋅(A−C)+(A−C)⋅(A−C)−r^2=0<br>$$<br>①当视线与球体相交的时候，t可取两个值，分别为 t1=(-b - sqrt(b * b - 4ac))/ (2.0 * a)， t2=(-b + sqrt(b * b - 4ac))/ (2.0 * a)，t1是穿过去的交点P，t2是视线穿进球体的交点。当视线与球体相切时，t1=t2。</p><p>②得到t后，调用ray.h的at()，计算出该点的P(t)，从而法线向量等于P(t)-C，对其进行单位化得到单位法线向量。</p><p>③返回一个color类的变量，把大小控制在(0,1)</p><p>所以需要更改main.c的代码，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hit_sphere</span><span class="params">(<span class="keyword">const</span> point3&amp; center, <span class="keyword">double</span> radius, <span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.origin() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = dot(r.direction(), r.direction());</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="number">2.0</span> * dot(oc, r.direction());</span><br><span class="line">    <span class="keyword">auto</span> c = dot(oc, oc) - radius*radius;</span><br><span class="line">    <span class="keyword">auto</span> discriminant = b*b - <span class="number">4</span>*a*c;</span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (-b - <span class="built_in">sqrt</span>(discriminant) ) / (<span class="number">2.0</span>*a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = hit_sphere(point3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="number">0.5</span>, r);</span><br><span class="line">    <span class="keyword">if</span> (t &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">        vec3 N = unit_vector(r.at(t) - vec3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span>*color(N.x()+<span class="number">1</span>, N.y()+<span class="number">1</span>, N.z()+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = unit_vector(r.direction());</span><br><span class="line">    t = <span class="number">0.5</span>*(unit_direction.y() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*color(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*color(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pictures/RayTracing/02/3.png" alt="A sphere colored according to its normal vectors"></p><h5 id="6-2-Simplifying-the-Ray-Sphere-Intersection-Code"><a href="#6-2-Simplifying-the-Ray-Sphere-Intersection-Code" class="headerlink" title="6.2  Simplifying the Ray-Sphere Intersection Code"></a>6.2  Simplifying the Ray-Sphere Intersection Code</h5><p>对hit_sphere()进行优化：</p><p>①向量与自身的点乘，等于向量的长度的平方(在vec3.h中定义的length_squared()就是这个原理)</p><p>②假定b=2h，对二次方程的结果进行优化，<br>$$<br>\frac{-b \pm \sqrt{b^2 - 4ac}}{2a}<br>=\frac{-2h \pm \sqrt{(2h)^2 - 4ac}}{2a}<br>=\frac{-2h \pm 2\sqrt{h^2 - ac}}{2a}<br>=\frac{-h \pm \sqrt{h^2 - ac}}{a}<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hit_sphere</span><span class="params">(<span class="keyword">const</span> point3&amp; center, <span class="keyword">double</span> radius, <span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    vec3 oc = r.origin() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.direction().length_squared();</span><br><span class="line">    <span class="keyword">auto</span> half_b = dot(oc, r.direction());<span class="comment">//b=2h，只取原来的一半</span></span><br><span class="line">    <span class="keyword">auto</span> c = oc.length_squared() - radius*radius;</span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b*half_b - a*c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (-half_b - <span class="built_in">sqrt</span>(discriminant) ) / a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Ray Tracing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随机快排</title>
      <link href="2020/10/21/%E9%9A%8F%E6%9C%BA%E5%BF%AB%E6%8E%92/"/>
      <url>2020/10/21/%E9%9A%8F%E6%9C%BA%E5%BF%AB%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<p>快排在选取主元的时候，每次都选取最右边的元素。当序列为有序时，会发现划分出来的两个子序列一个里面没有元素，而另一个则只比原来少一个元素。为了避免这种情况，引入一个随机化量来破坏这种有序状态。</p><p>在随机化的快排里面，选取a[left..right]中的随机一个元素作为主元，然后再进行划分，就可以得到一个平衡的划分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> random(x) rand()%(x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">t=a[n];</span><br><span class="line">a[n]=a[m];</span><br><span class="line">a[m]=t;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">int</span> * <span class="title">partition</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> less=L<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> more=R;</span><br><span class="line"><span class="keyword">while</span>(L&lt;more)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[L]&lt;a[R])</span><br><span class="line">swap(a,++less,L++);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[L]&gt;a[R])</span><br><span class="line">swap(a,L,--more);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[L]==a[R]) </span><br><span class="line">&#123; </span><br><span class="line">L++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(a,more,R);</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">2</span>]=&#123;less+<span class="number">1</span>,more&#125;;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L&lt;R)</span><br><span class="line">&#123;</span><br><span class="line">swap(a,random(R-L+<span class="number">1</span>),R);<span class="comment">//与经典快排不同，随机在数组中选择一个数字进行比较 </span></span><br><span class="line"><span class="keyword">int</span> *p=partition(a,L,R);</span><br><span class="line">quicksort(a,L,p[<span class="number">0</span>]<span class="number">-1</span>);</span><br><span class="line">quicksort(a,p[<span class="number">1</span>]+<span class="number">1</span>,R);</span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"> <span class="keyword">int</span> a[n];</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"> &#125;</span><br><span class="line"> quicksort(a,<span class="number">0</span>,n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>多次实验结果：</p><p><strong>10w：</strong></p><table><thead><tr><th>算法</th><th>第1次耗时</th><th>第2次耗时</th><th>第3次耗时</th><th>平均耗时</th></tr></thead><tbody><tr><td>普通快排</td><td>13ms</td><td>15ms</td><td>15ms</td><td>14.333ms</td></tr><tr><td>随机化版本快排</td><td>25ms</td><td>25ms</td><td>27ms</td><td>25.667ms</td></tr></tbody></table><p><strong>100w：</strong></p><table><thead><tr><th>算法</th><th>第1次耗时</th><th>第2次耗时</th><th>第3次耗时</th><th>平均耗时</th></tr></thead><tbody><tr><td>普通快排</td><td>101ms</td><td>103ms</td><td>96ms</td><td>100ms</td></tr><tr><td>随机化版本快排</td><td>119ms</td><td>101ms</td><td>105ms</td><td>108.333ms</td></tr></tbody></table><p><strong>1000w：</strong></p><table><thead><tr><th>算法</th><th>第1次耗时</th><th>第2次耗时</th><th>第3次耗时</th><th>平均耗时</th></tr></thead><tbody><tr><td>普通快排</td><td>1397ms</td><td>1379ms</td><td>1338ms</td><td>1371.333ms</td></tr><tr><td>随机化版本快排</td><td>1241ms</td><td>1187ms</td><td>1258ms</td><td>1228.667ms</td></tr></tbody></table><p>随机化快排因为要生成随机数，所以有一些性能损失，所以数据规模较小，数据分布均匀时普通快排还是比随机化快排要快些的，不过随着数据规模的上升，随机化快排的性能优势就展现出来了。</p><p><strong>有序序列</strong></p><p>下来才是展示快排才华的时候，假设当输入数组已经是排好序的，这两个算法的性能差距又有多少？<br>之前的数组生成代码不变，只是在调用两个算法之前，先调用一下快排将数组排序，然后将两个有序的数组作为参数传进去。</p><p><strong>10w：</strong></p><p>10w的普通快排……已经栈溢出了。</p><table><thead><tr><th>算法</th><th>第1次耗时</th><th>第2次耗时</th><th>第3次耗时</th><th>平均耗时</th></tr></thead><tbody><tr><td>普通快排</td><td>溢出</td><td>溢出</td><td>溢出</td><td>溢出</td></tr><tr><td>随机化版本快排</td><td>15ms</td><td>7ms</td><td>6ms</td><td>9.333ms</td></tr></tbody></table><p><strong>1w：</strong></p><p>试一试1w的</p><table><thead><tr><th>算法</th><th>第1次耗时</th><th>第2次耗时</th><th>第3次耗时</th><th>平均耗时</th></tr></thead><tbody><tr><td>普通快排</td><td>98ms</td><td>94ms</td><td>92ms</td><td>94.667ms</td></tr><tr><td>随机化版本快排</td><td>2ms</td><td>1ms</td><td>0ms</td><td>1ms</td></tr></tbody></table><p><strong>1000w：</strong></p><p>看下1000w下随机化快排是否有影响</p><table><thead><tr><th>算法</th><th>第1次耗时</th><th>第2次耗时</th><th>第3次耗时</th><th>平均耗时</th></tr></thead><tbody><tr><td>随机化版本快排</td><td>696ms</td><td>733ms</td><td>689ms</td><td>706ms</td></tr></tbody></table><p><em>参考书籍：机械工业出版社 第三版<strong>《算法导论》</strong>部分内容引自原书</em></p>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL学习笔记01-GLFW、GLAD、GLUT配置方法</title>
      <link href="2020/10/19/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-GLFW%E3%80%81GLAD%E3%80%81GLUT%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
      <url>2020/10/19/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-GLFW%E3%80%81GLAD%E3%80%81GLUT%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><strong>1.GLFW</strong></p><p><a href="https://www.glfw.org/download.html">https://www.glfw.org/download.html</a></p><p>进入该网站直接下载<a href="https://github.com/glfw/glfw/releases/download/3.3.2/glfw-3.3.2.bin.WIN32.zip">32-bit Windows binaries</a></p><p>ps:注意旁边的提示，vs10及以上的下载64位，其他下载32位，下载好后，直接解压。</p><p><img src="/pictures/OpenGL/01/1.png" alt="GLFW下载页面"></p><p><strong>2.GLAD</strong></p><p><a href="https://glad.dav1d.de/">https://glad.dav1d.de/</a></p><p><img src="/pictures/OpenGL/01/2.png" alt="GLAD下载页面"></p><p>如图所示，其中gl选择最新版的即可。选择好后，Options中勾选 Generate a loader,再点击下方GENERATE。</p><p><img src="/pictures/OpenGL/01/3.png" alt="GENERATE"></p><p>下载后解压，此时你将得到这两个文件夹。</p><p><img src="/pictures/OpenGL/01/image-20201011191208599.png" alt="解压后的文件夹"></p><p>再新建一个文件夹（例如：OpenGL，不要是中文），新建三个子文件夹，分别为include,lib,src。</p><p>将glfw-3.3.2.bin.WIN64-&gt;include-&gt;GLFW复制到OpenGL-&gt;include中</p><p><img src="/pictures/OpenGL/01/image-20201011191714672.png" alt="GLFW文件路径"></p><p>将glfw-3.3.2.bin.WIN64-&gt;lib-vc2019(对应你所使用的版本)-&gt;glfw3.lib复制到OpenGL-&gt;lib中</p><p><img src="/pictures/OpenGL/01/image-20201011191802906.png" alt="glfw3.lib文件路径"></p><p>将glad-&gt;include下面的两个文件夹全部复制到OpenGL-&gt;include中</p><p><img src="/pictures/OpenGL/01/image-20201011191957265.png" alt="glad-&gt;iinclude路径"></p><p>将glad-&gt;src下的内容复制到OpenGL-&gt;src中</p><p><img src="/pictures/OpenGL/01/image-20201011192202606.png" alt="glad-&gt;src文件路径"></p><p>在vs中新建一个空项目</p><p><img src="/pictures/OpenGL/01/image-20201011192545752.png" alt="新建空项目"></p><p>将刚刚建好的OpenGL文件夹复制到和项目同级目录中</p><p><img src="/pictures/OpenGL/01/image-20201011192736579.png" alt="OpenGL移动位置"></p><p>右键项目选择属性，VC++目录-&gt;包含目录，将OpenGL中的include文件夹添加进来，再选择VC++目录-&gt;库目录，将OpenGL中的lib文件夹添加进来。</p><p>ps：记得选择所有配置，所有平台</p><p><img src="/pictures/OpenGL/01/image-20201011193306706.png" alt="修改包含目录"></p><p><img src="/pictures/OpenGL/01/image-20201011193226797.png" alt="修改库目录"></p><p>在链接器-&gt;输入-&gt;附加依赖项选项卡里添加<br><code>opengl32.lib</code><br><code>glfw3.lib</code><br><img src="/pictures/OpenGL/01/image-20201011193522438.png" alt="添加附加依赖"></p><p>填写完成后，点击应用，确定后退出。</p><p>右键源文件，添加现有项，将OpenGl-&gt;src下的glad.c文件添加进来</p><p><img src="/pictures/OpenGL/01/image-20201011193656048.png" alt="右键源文件"><br><img src="/pictures/OpenGL/01/image-20201011193712712.png" alt="添加glad.c"></p><p>一切完成后，新建一个cpp文件，跑测试代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">    <span class="comment">// ------------------------------</span></span><br><span class="line">    glfwInit();</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render loop</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        processInput(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        <span class="comment">// ------</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the viewport matches the new window dimensions; note that width and </span></span><br><span class="line">    <span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pictures/OpenGL/01/image-20201011194022926.png" alt="正确运行结果"></p><p>如果运行报错，将这里改为x64后，再运行！！！</p><p><img src="/pictures/OpenGL/01/image-20201011194103668.png" alt="若报错记得修改x64"></p><p>喜大普奔！！！GLFW和GLAD安装成功！！！</p><p><strong>3.GLUT</strong></p><p><img src="/pictures/OpenGL/01/image-20201011195655178.png" alt="GLUT下载页面"></p><p><a href="https://www.opengl.org/resources/libraries/glut/">https://www.opengl.org/resources/libraries/glut/</a></p><p>从官网得知目前推荐使用freeglut。这里提供一个OpenGL库，比较方便。<a href="https://pan.baidu.com/s/1iXQTo2dBgkD8zLE8AblgqA">https://pan.baidu.com/s/1iXQTo2dBgkD8zLE8AblgqA</a> 提取码：yvtx<br>下载后解压，配置OpenGL也就是需要把这include,dll,lib三个文件夹放到安装对应的文件夹中。</p><p>按照下图路径找到对应文件夹，下图是vs2019的路径，其他版本可以自行寻找。</p><p><img src="/pictures/OpenGL/01/image-20201011200105772.png" alt="vs2019对应路径"></p><p>将解压得到的lib文件夹和include文件夹复制到图中对应的文件夹中<br>再把dll文件夹中的5个dll文件粘贴到C:\Windows\System32和C:\Windows\SysWOW64</p><p>再运行测试代码，正确结果如下图所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openGL/glut.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">glClearColor(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line"> </span><br><span class="line">glMatrixMode(GL_PROJECTION);</span><br><span class="line">gluOrtho2D(<span class="number">0.0</span>, <span class="number">200.0</span>, <span class="number">0.0</span>, <span class="number">150.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lineSegment</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">glColor3f(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">glBegin(GL_LINES);</span><br><span class="line">glVertex2i(<span class="number">180</span>, <span class="number">15</span>);</span><br><span class="line">glVertex2i(<span class="number">10</span>, <span class="number">145</span>);</span><br><span class="line">glEnd();</span><br><span class="line"> </span><br><span class="line">glFlush();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">glutInit(&amp;argc, argv);</span><br><span class="line">glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);</span><br><span class="line">glutInitWindowPosition(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">glutInitWindowSize(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">glutCreateWindow(<span class="string">&quot;Demo OpenGL Program&quot;</span>);</span><br><span class="line"> </span><br><span class="line">init();</span><br><span class="line">glutDisplayFunc(lineSegment);</span><br><span class="line">glutMainLoop();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pictures/OpenGL/01/image-20201011200310469.png" alt="正确运行结果"></p><p>ps：这里是#include &lt;openGL/glut.h&gt;，因为glut.h头文件保存在openGL文件夹中。网上有的教程的测试代码或者教学代码是#include &lt;GL/glut.h&gt;，直接复制用来跑代码要先修改。</p><p><strong>按照上述操作，你已经可以开始OpenGL学习，无论你是使用蓝宝书学习还是在<a href="https://learnopengl-cn.github.io/%E4%B8%AD%E5%AD%A6%E4%B9%A0%EF%BC%8C%E9%83%BD%E5%A4%9F%E7%94%A8%E4%BA%86%E3%80%82">https://learnopengl-cn.github.io/中学习，都够用了。</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Ray Tracing in a Weekend》学习笔记01</title>
      <link href="2020/10/18/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
      <url>2020/10/18/%E3%80%8ARay%20Tracing%20in%20a%20Weekend%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
      
        <content type="html"><![CDATA[<p>一、前期准备工作</p><p>1.下载一个<a href="http://www.121down.com/soft/softview-42834.html">ppmview</a>，用来看效果图。</p><p>2.需要你会C/C++</p><p>二、学习小结</p><p>黑体标题是按原文的标题来的，简单的章节会自动跳动。</p><h4 id="2-Output-an-Image"><a href="#2-Output-an-Image" class="headerlink" title="2.Output an Image"></a><strong>2.Output an Image</strong></h4><p>介绍了一下PPM</p><p><img src="/pictures/RayTracing/01/7.png" alt="PPM"></p><p>作者给的main.c代码，运行结果就是输出一张简单的图片，运行结果见原书。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Image</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> r = <span class="keyword">double</span>(i) / (image_width<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> g = <span class="keyword">double</span>(j) / (image_height<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> b = <span class="number">0.25</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> ir = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * r);</span><br><span class="line">            <span class="keyword">int</span> ig = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * g);</span><br><span class="line">            <span class="keyword">int</span> ib = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * b);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ir &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ig &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ib &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有以下几个问题需要注意：</p><p>1.使用会auto报错。默认把auto当做声明为自动变量。（自动变量意为拥有自动的生命周期）。这是C++98的标准。可自行百度auto在c++中的使用。</p><p>解决办法：</p><p>版本：Dev-C++ 4.8.1及以上<br>找到：工具- &gt;编译选项- &gt;程序<br>对应项改为：g++ -std=c++11</p><p>2.直接运行作者的代码是看不到效果图的，通过使用 “**&gt;**” 重定向运算符来生成ppm文件(对着目录文件夹shift＋鼠标右键，选择powershell打开)，再用记事本打开ppm文件，按图示将编码改为UTF-8（这里也可以直接用notepad++修改更方便）。再将<a href="https://convertio.co/zh/txt-ppm/">txt文件转换为ppm格式</a>，就可以用PMView打开查看效果图。</p><p><img src="/pictures/RayTracing/01/2.png" alt="生成ppm文件"></p><p>记事本修改方法，较麻烦不推荐：</p><p><img src="/pictures/RayTracing/01/3.png" alt="记事本修改"></p><p>notepad++修改方法更简单：</p><p><img src="/pictures/RayTracing/01/image-20201015223955099.png" alt="notepad++修改"></p><p><img src="/pictures/RayTracing/01/4.png" alt="效果图"></p><h4 id="3-The-vec3-Class"><a href="#3-The-vec3-Class" class="headerlink" title="3.The vec3 Class"></a><strong>3.The vec3 Class</strong></h4><p>几乎所有的图形程序都有一些用于存储几何矢量和颜色的类。 在许多系统中，这些向量是4D（3D加上几何的齐次坐标，而RGB加上颜色的alpha透明通道）。 就我们的目的而言，三个坐标就足够了。 我们将对颜色，位置，方向，偏移量等使用相同的vec3类。</p><h5 id="3-1-Variables-and-Methods"><a href="#3-1-Variables-and-Methods" class="headerlink" title="3.1 Variables and Methods"></a><strong>3.1 Variables and Methods</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vec3.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> VEC3_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VEC3_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">sqrt</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vec3</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vec3() : e&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125; &#123;&#125;<span class="comment">//默认向量为(0,0,0)</span></span><br><span class="line">        vec3(<span class="keyword">double</span> e0, <span class="keyword">double</span> e1, <span class="keyword">double</span> e2) : e&#123;e0, e1, e2&#125; &#123;&#125;<span class="comment">//有初始值的向量</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">0</span>]; &#125;<span class="comment">//返回x值</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">1</span>]; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">z</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">2</span>]; &#125;</span><br><span class="line"></span><br><span class="line">        vec3 <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123; <span class="keyword">return</span> vec3(-e[<span class="number">0</span>], -e[<span class="number">1</span>], -e[<span class="number">2</span>]); &#125;<span class="comment">//重载-</span></span><br><span class="line">        <span class="keyword">double</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> e[i]; &#125;<span class="comment">//重载[]</span></span><br><span class="line">        <span class="keyword">double</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> e[i]; &#125;<span class="comment">//见注意事项</span></span><br><span class="line"></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> vec3 &amp;v) &#123;<span class="comment">//重载+=</span></span><br><span class="line">            e[<span class="number">0</span>] += v.e[<span class="number">0</span>];</span><br><span class="line">            e[<span class="number">1</span>] += v.e[<span class="number">1</span>];</span><br><span class="line">            e[<span class="number">2</span>] += v.e[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>*=(<span class="keyword">const</span> <span class="keyword">double</span> t) &#123;<span class="comment">//重载*=</span></span><br><span class="line">            e[<span class="number">0</span>] *= t;</span><br><span class="line">            e[<span class="number">1</span>] *= t;</span><br><span class="line">            e[<span class="number">2</span>] *= t;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vec3&amp; <span class="keyword">operator</span>/=(<span class="keyword">const</span> <span class="keyword">double</span> t) &#123;<span class="comment">//重载/=</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span> *= <span class="number">1</span>/t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="comment">//返回向量长度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sqrt</span>(length_squared());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">length_squared</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e[<span class="number">0</span>]*e[<span class="number">0</span>] + e[<span class="number">1</span>]*e[<span class="number">1</span>] + e[<span class="number">2</span>]*e[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">double</span> e[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type aliases for vec3</span></span><br><span class="line"><span class="keyword">using</span> point3 = vec3;   <span class="comment">// 3D point</span></span><br><span class="line"><span class="keyword">using</span> color = vec3;    <span class="comment">// RGB color</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>注意事项：</p><p>C++中，const类型对象只能调用const成员函数，但非const类型对象对于重载了const和非const的函数，会优先调用非const函数。这也提醒我们对于确定不想改变的变量，一定要定义为const类型，防止调用了某个非const的成员函数改变了对象数据却没有发现！</p><p>一个类重载operator[] ()函数时，要重载operator[]两次，一个是const函数，一个是非const函数。const函数的返回值用按值传递，非const函数的返回值用引用。只实现一次重载，在某些情况下是会报错的。</p><h5 id="3-2-vec3-Utility-Functions"><a href="#3-2-vec3-Utility-Functions" class="headerlink" title="3.2 vec3 Utility Functions"></a><strong>3.2 vec3 Utility Functions</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vec3.h</span></span><br><span class="line"><span class="comment">// vec3 Utility Functions</span></span><br><span class="line"><span class="comment">//inline是C++关键字，在函数声明或定义中，函数返回类型前加上关键字inline，即可以把函数指定为内联函数。    这样可以解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题</span></span><br><span class="line"><span class="comment">//重载输出运算符&lt;&lt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; v.e[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载运算符+</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>+(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> vec3(u.e[<span class="number">0</span>] + v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] + v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] + v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载运算符-</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>-(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> vec3(u.e[<span class="number">0</span>] - v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] - v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] - v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载运算符*，vec*vec</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> vec3(u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载运算符*，double*vec</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">double</span> t, <span class="keyword">const</span> vec3 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> vec3(t*v.e[<span class="number">0</span>], t*v.e[<span class="number">1</span>], t*v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载运算符*，vec*double</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="keyword">const</span> vec3 &amp;v, <span class="keyword">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t * v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载运算符/，vec/double</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>/(vec3 v, <span class="keyword">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>/t) * v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义点乘函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dot</span><span class="params">(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>]</span><br><span class="line">         + u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>]</span><br><span class="line">         + u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义叉乘函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">cross</span><span class="params">(<span class="keyword">const</span> vec3 &amp;u, <span class="keyword">const</span> vec3 &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> vec3(u.e[<span class="number">1</span>] * v.e[<span class="number">2</span>] - u.e[<span class="number">2</span>] * v.e[<span class="number">1</span>],</span><br><span class="line">                u.e[<span class="number">2</span>] * v.e[<span class="number">0</span>] - u.e[<span class="number">0</span>] * v.e[<span class="number">2</span>],</span><br><span class="line">                u.e[<span class="number">0</span>] * v.e[<span class="number">1</span>] - u.e[<span class="number">1</span>] * v.e[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义转换单位向量函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">unit_vector</span><span class="params">(vec3 v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v / v.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-Color-Utility-Functions"><a href="#3-3-Color-Utility-Functions" class="headerlink" title="3.3  Color Utility Functions"></a><strong>3.3  Color Utility Functions</strong></h5><p>pixel_color的x,y,z大小都控制在（0,1），所以要转成RGB颜色，得乘上255.99。</p><p>新建一个color.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//color.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COLOR_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_color</span><span class="params">(<span class="built_in">std</span>::ostream &amp;out, color pixel_color)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Write the translated [0,255] value of each color component.</span></span><br><span class="line">    <span class="comment">//编写每个颜色分量的转换后的[0,255]值。</span></span><br><span class="line">    out &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * pixel_color.x()) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * pixel_color.y()) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * pixel_color.z()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>现在main.c函数就要改成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Image</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="comment">//把image的所有像素调用write_color</span></span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="keyword">double</span>(i)/(image_width<span class="number">-1</span>), <span class="keyword">double</span>(j)/(image_height<span class="number">-1</span>), <span class="number">0.25</span>)</span></span>;</span><br><span class="line">            write_color(<span class="built_in">std</span>::<span class="built_in">cout</span>, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Rays-a-Simple-Camera-and-Background"><a href="#4-Rays-a-Simple-Camera-and-Background" class="headerlink" title="4.   Rays, a Simple Camera, and Background"></a><strong>4.   Rays, a Simple Camera, and Background</strong></h4><h5 id="4-1-The-ray-Class"><a href="#4-1-The-ray-Class" class="headerlink" title="4.1  The ray Class"></a><strong>4.1  The ray Class</strong></h5><p>视线公式 P(t) = a + t ·b</p><p>新建ray.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ray.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ray</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ray() &#123;&#125;</span><br><span class="line">        ray(<span class="keyword">const</span> point3&amp; origin, <span class="keyword">const</span> vec3&amp; direction)</span><br><span class="line">            : orig(origin), dir(direction)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">point3 <span class="title">origin</span><span class="params">()</span> <span class="keyword">const</span>  </span>&#123; <span class="keyword">return</span> orig; &#125;</span><br><span class="line">        <span class="function">vec3 <span class="title">direction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> dir; &#125; </span><br><span class="line">        <span class="comment">//P（t）= A + tb</span></span><br><span class="line">        <span class="function">point3 <span class="title">at</span><span class="params">(<span class="keyword">double</span> t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> orig + t*dir;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        point3 orig;</span><br><span class="line">        vec3 dir;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h5 id="4-2-Sending-Rays-Into-the-Scene"><a href="#4-2-Sending-Rays-Into-the-Scene" class="headerlink" title="4.2  Sending Rays Into the Scene"></a><strong>4.2  Sending Rays Into the Scene</strong></h5><p>Now we are ready to turn the corner and make a ray tracer. <strong>At the core</strong>, the ray tracer sends rays through pixels and computes the color seen in the direction of those rays. The involved steps are <strong>(1) calculate the ray from the eye to the pixel, (2) determine which objects the ray intersects, and (3) compute a color for that intersection point.</strong></p><p>本文的项目是使用的是16:9的宽高比，坐标(0,0,0)放置的是摄像机位置（眼睛），四个蓝点确定屏幕。</p><p><img src="/pictures/RayTracing/01/fig-1.03-cam-geom.jpg" alt="坐标系示意图"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(<span class="keyword">const</span> ray&amp; r)</span> </span>&#123;</span><br><span class="line">    vec3 unit_direction = unit_vector(r.direction());<span class="comment">//获得r的单位方向向量</span></span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span>*(unit_direction.y() + <span class="number">1.0</span>);<span class="comment">//使得 0&lt;t&lt;1</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>-t)*color(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t*color(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Image</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">//保证宽高比为16:9</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> image_height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Camera</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;<span class="comment">//屏幕高度</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;<span class="comment">//屏幕宽度</span></span><br><span class="line">    <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;<span class="comment">//视距</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> origin = point3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//摄像机位置</span></span><br><span class="line">    <span class="keyword">auto</span> horizontal = vec3(viewport_width, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//屏幕水平方向最远点</span></span><br><span class="line">    <span class="keyword">auto</span> vertical = vec3(<span class="number">0</span>, viewport_height, <span class="number">0</span>);<span class="comment">//屏幕垂直方向最高点</span></span><br><span class="line">    <span class="comment">//lower_left_corner获得屏幕左下角的位置</span></span><br><span class="line">    <span class="keyword">auto</span> lower_left_corner = origin - horizontal/<span class="number">2</span> - vertical/<span class="number">2</span> - vec3(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P3\n&quot;</span> &lt;&lt; image_width &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; image_height &lt;&lt; <span class="string">&quot;\n255\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = image_height<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = <span class="keyword">double</span>(i) / (image_width<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">auto</span> v = <span class="keyword">double</span>(j) / (image_height<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//从左下角开始，从下往上，从左向右，一行一行遍历</span></span><br><span class="line">            <span class="comment">//lower_left_corner + u*horizontal + v*vertical - origin  视线方向向量</span></span><br><span class="line">            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u*horizontal + v*vertical - origin)</span></span>;</span><br><span class="line">            color pixel_color = ray_color(r);</span><br><span class="line">            write_color(<span class="built_in">std</span>::<span class="built_in">cout</span>, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps:在将射线方向缩放到单位长度（因此-1.0 &lt;y &lt;1.0）之后，ray_color（ray）函数根据y坐标的高度线性混合白色和蓝色。 因为我们是在对向量进行归一化之后查看y高度，所以除了垂直渐变之外，您还会注意到颜色的水平渐变。<br>       然后，做了一个标准的图形技巧，将其缩放到0.0≤t≤1.0。 当t = 1.0时我想要蓝色。 当t = 0.0时我想要白色。 在这两者之间，我要混合。 这在两件事之间形成“线性混合”或“线性插值”或简称“ lerp”。  lerp总是形式<br>$$<br>blendedValue=(1−t)⋅startValue+t⋅endValue<br>$$<br>①确定分辨率，设定宽度image_width，通过宽高比算出高度image_width。相当于确定像素数量</p><p>②确定开始位置lower_left_corner，从viewport左下角开始计算，自下而上，自左向右，按行遍历。</p><p>③确定分辨率下的位置。lower_left_corner + u + v </p><p>④映射。要将分辨率下的位置转换到屏幕的屏幕坐标。例如分辨下的水平长度x=100。先将n=100/image_width-1，得到0&lt;n&lt;1，再将n * horizontal，就得到屏幕上的长度。lower_left_corner + u*horizontal + v *vertical</p><p>⑤最后再减去摄像机的位置，即可得到视线方向向量。</p><p>ray_color（const ray＆r）：将视线向量进行单位化，算出r的单位向量，将该向量的y，控制在（0,1）之间，通过线性差值的方法，使得图像出现渐变色。</p><p>write_color(std::ostream &amp;out, color pixel_color) ：pixel_color.x()乘255.999的目的就是把输出值控制在[0,255]之间，因为pixel_color.x()是在(0,1)之间。</p><p><img src="/pictures/RayTracing/01/image-20201016112514547.png" alt="效果图"></p><p>小总结：从viewport左下角开始计算，自下而上，自左向右，按行遍历像素。调用ray_color，计算光线在该像素的pixel_color。再调用write_color记录下该像素点的RGB。</p>]]></content>
      
      
      <categories>
          
          <category> Ray Tracing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="2020/10/12/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>2020/10/12/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-XTtJyWGM" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1481164987" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#3F51B5"    ></div><p>堆是一种数据结构，一种叫做完全二叉树的数据结构。</p><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p><p>大顶堆：a[i] &gt;=a[2i+1] &amp;&amp; ar[i] &gt;= a[2i+2]  </p><p>小顶堆：a[i] &lt;= a[2i+1] &amp;&amp; a[i] &lt;= a[2i+2]  </p><p><strong>堆排序的基本思想：</strong></p><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p><p>算法思想：</p><p>1.把一组数据a[n]调整成大根堆或小根堆,用heapSize来实时记录数组尚未排序的数据的数量，初始值为a[n]长度n</p><p>2.将a[0]与a[–heapSize]交换值，因为一开始就把数据调整为大根堆，该步骤相当于把已经找出数组中最大的数据，并放到了最后一位，不再处理。</p><p>3.a[0]与a[–heapSize]交换值后，也破坏了大根堆，但除了a[0]以外，数组其他数据还是保持大根堆状态。此时就是一直将a[0]数据“下沉”，让他不断和孩子节点比较，直到找到孩子节点都比它小，停止“下沉”，被破坏了的大根堆又重新被调整为大根堆。不断–heapSize，不断调整大根堆，每次都把a[0]与a[–heapSize]交换值，最终数组有序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">t=a[n];</span><br><span class="line">a[n]=a[m];</span><br><span class="line">a[m]=t;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> index,<span class="keyword">int</span> heapsize)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span>(left&lt;heapsize)<span class="comment">//判断左孩子是否越界，若越界说明左孩子已经到达最下面 </span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">//比较两个孩子谁的值大 ，谁的值大谁就是largest </span></span><br><span class="line"> <span class="keyword">int</span> largest=left+<span class="number">1</span>&lt;heapsize&amp;&amp;a[left+<span class="number">1</span>]&gt;a[left]?left+<span class="number">1</span>:left;</span><br><span class="line"> <span class="comment">//比较父节点和孩子节点的大小</span></span><br><span class="line"> largest=a[largest]&gt;a[index]?largest:index; </span><br><span class="line"> <span class="keyword">if</span>(largest==index)<span class="comment">//若发现孩子节点都比a[index]小，则循环结束</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> swap(a,largest,index);</span><br><span class="line"> index=largest;</span><br><span class="line"> left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> index)</span><span class="comment">//把数组调成大根堆 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(a[index]&gt;a[(index<span class="number">-1</span>)/<span class="number">2</span>])</span><br><span class="line">&#123;</span><br><span class="line">swap(a,index,(index<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">index=(index<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="literal">NULL</span>||n&lt;<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">heapInsert(a,i);</span><br><span class="line"><span class="keyword">int</span> heapSize=n;</span><br><span class="line">swap(a,<span class="number">0</span>,--heapSize);<span class="comment">//交换后大根堆的最大的值到数组最后一个位置 </span></span><br><span class="line"><span class="keyword">while</span>(heapSize&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//每次都把数组中0-heapSize调整成大根堆 </span></span><br><span class="line">heapify(a,<span class="number">0</span>,heapSize);</span><br><span class="line">swap(a,<span class="number">0</span>,--heapSize);</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"> <span class="keyword">int</span> a[n];</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"> &#125;</span><br><span class="line"> heapSort(a,n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>荷兰国旗</title>
      <link href="2020/10/10/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97/"/>
      <url>2020/10/10/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数数组，给定一个值K，这个值在原数组中一定存在，要求把数组中小于K的元素放到数组的左边，大于K的元素放到数组的右边，等于K的元素放到数组的中间，最终返回一个整数数组，其中只有两个值，分别是等于K的数组部分的左右两个下标值。</p><p>例如，给定数组：[2, 3, 1, 9, 7, 6, 1, 4, 5]，给定一个值4，那么经过处理原数组可能得一种情况是：[2, 3, 1, 1, 4, 9, 7, 6, 5]， 需要注意的是，小于4的部分不需要有序，大于4的部分也不需要有序，返回等于4部分的左右两个下标，即[4, 4]</p><p>解析：有一点快排的思想。把数组分成三个区域，分别是less，equal，more。一直都是less区域推着equal区域挤压more区域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span><span class="comment">//交换数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">t=a[n];</span><br><span class="line">a[n]=a[m];</span><br><span class="line">a[m]=t;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> less=L<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> more=R+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(L&lt;more)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//L一直都是指向正在进行比较的数字 </span></span><br><span class="line"><span class="keyword">if</span>(a[L]&lt;num)<span class="comment">//如果小于num，less区域就要向右扩大，less++和L进行交换 </span></span><br><span class="line">swap(a,++less,L++);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[L]&gt;num)<span class="comment">//如果小于num，more区域就要向左扩大，--more和L进行交换 </span></span><br><span class="line">swap(a,L,--more);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[L]==num)<span class="comment">//如果等于num，则直接把L++，这样即可保证相等区域一直没有变动。 </span></span><br><span class="line">&#123; </span><br><span class="line">L++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n,num;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;num;</span><br><span class="line"> <span class="keyword">int</span> a[n];</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"> &#125;</span><br><span class="line"> partition(a,<span class="number">0</span>,n<span class="number">-1</span>,num);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆序对</title>
      <link href="2020/10/09/%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
      <url>2020/10/09/%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://www.nowcoder.com/questionTerminal/f50f89c3b4624cd6aa3312747cd45879">https://www.nowcoder.com/questionTerminal/f50f89c3b4624cd6aa3312747cd45879</a><br>来源：牛客网</p><p>给定一个长度为n的排列A,逆序的定义：(i,j)为逆序对，当i&lt;j &amp;&amp; A[i]&gt;A[j] </p><p>  求排列A的逆序对数量。 </p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行一个整数n，表示排列的长度.</span><br><span class="line">第二行n个元素，表示A排列.</span><br></pre></td></tr></table></figure><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出逆序对的数量</span><br></pre></td></tr></table></figure><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 2 4 1 5</span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>解析：原理是归并排序，在每次merge之前，比较左右两边的大小，若出现当i&lt;j &amp;&amp; A[i]&gt;A[j] ，则逆序对数量加一。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> L,<span class="keyword">int</span> mid,<span class="keyword">int</span> R)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> a[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;mergeSort(a,n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="literal">NULL</span>||n&lt;<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> sortProcess(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L&gt;=R)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid=L+((R-L)&gt;&gt;<span class="number">1</span>);<span class="comment">//相当于(L+R)/2,可有效避免溢出 </span></span><br><span class="line"><span class="keyword">return</span>sortProcess(a,L,mid)+sortProcess(a,mid+<span class="number">1</span>,R)+merge(a,L,mid,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> L,<span class="keyword">int</span> mid,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> help[R-L+<span class="number">1</span>];<span class="comment">//保存每次merge后的数组 </span></span><br><span class="line"><span class="built_in">memset</span>(help, <span class="number">0</span>, <span class="keyword">sizeof</span>(help));</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> p1=L;</span><br><span class="line"><span class="keyword">int</span> p2=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> rul=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p1&lt;=mid&amp;&amp;p2&lt;=R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//设任意p1&lt;m&lt;mid,当a[p1]&gt;a[p2]时，a[m]&lt;a[p2]也显然成立，m的数量为 mid-p1+1</span></span><br><span class="line"><span class="comment">//rul+=a[p1]&lt;=a[p2]?(R-p2+1)*a[p1]:0;</span></span><br><span class="line">rul+=a[p1]&gt;a[p2]?(mid-p1+<span class="number">1</span>):<span class="number">0</span>;</span><br><span class="line">help[i++]=a[p1]&lt;=a[p2]?a[p1++]:a[p2++];<span class="comment">//每次选择小的数字存入数组 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左右两边的数量不是每次都相等，将剩下的元素也添加到help数组中 </span></span><br><span class="line"><span class="keyword">while</span>(p1&lt;=mid)</span><br><span class="line">&#123;</span><br><span class="line">help[i++]=a[p1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(p2&lt;=R)</span><br><span class="line">&#123;</span><br><span class="line">help[i++]=a[p2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;R-L+<span class="number">1</span>;i++)</span><br><span class="line">a[L+i]=help[i];</span><br><span class="line"><span class="keyword">return</span> rul;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组小和</title>
      <link href="2020/10/08/%E6%95%B0%E7%BB%84%E5%B0%8F%E5%92%8C/"/>
      <url>2020/10/08/%E6%95%B0%E7%BB%84%E5%B0%8F%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://www.nowcoder.com/questionTerminal/edfe05a1d45c4ea89101d936cac32469">https://www.nowcoder.com/questionTerminal/edfe05a1d45c4ea89101d936cac32469</a><br>来源：牛客网</p><p>数组小和的定义如下： </p><p>  例如，数组s = [1, 3, 5, 2, 4, 6]，在s[0]的左边小于或等于s[0]的数的和为0；在s[1]的左边小于或等于s[1]的数的和为1；在s[2]的左边小于或等于s[2]的数的和为1+3=4；在s[3]的左边小于或等于s[3]的数的和为1； </p><p>  在s[4]的左边小于或等于s[4]的数的和为1+3+2=6；在s[5]的左边小于或等于s[5]的数的和为1+3+5+2+4=15。所以s的小和为0+1+4+1+6+15=27 </p><p>  给定一个数组s，实现函数返回s的小和 </p><p>   [要求]  </p><p>   时间复杂度为O(nlogn)，空间复杂度为O(n)  </p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行有一个整数N。表示数组长度</span><br><span class="line">接下来一行N个整数表示数组内的数</span><br></pre></td></tr></table></figure><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个整数表示答案</span><br></pre></td></tr></table></figure><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">1 3 5 2 4 6</span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">27</span><br></pre></td></tr></table></figure><h5 id="备注"><a href="#备注" class="headerlink" title="备注:"></a><strong>备注:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1⩽N⩽10^5</span><br><span class="line">−100⩽arri⩽100</span><br></pre></td></tr></table></figure><p>解：本质上是归并排序问题，只是在每次排序之前先检查出左边比右边小的数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> L,<span class="keyword">int</span> mid,<span class="keyword">int</span> R)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> a[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;mergeSort(a,n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="literal">NULL</span>||n&lt;<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> sortProcess(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L&gt;=R)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid=L+((R-L)&gt;&gt;<span class="number">1</span>);<span class="comment">//相当于(L+R)/2,可有效避免溢出 </span></span><br><span class="line"><span class="keyword">return</span>sortProcess(a,L,mid)+sortProcess(a,mid+<span class="number">1</span>,R)+merge(a,L,mid,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> L,<span class="keyword">int</span> mid,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> help[R-L+<span class="number">1</span>];<span class="comment">//保存每次merge后的数组 </span></span><br><span class="line"><span class="built_in">memset</span>(help, <span class="number">0</span>, <span class="keyword">sizeof</span>(help));</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> p1=L;</span><br><span class="line"><span class="keyword">int</span> p2=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> rul=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p1&lt;=mid&amp;&amp;p2&lt;=R)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//设任意p2&lt;m&lt;R,当a[p1]&lt;=a[p2]时，a[p1]&lt;a[m]也显然成立，m的数量为 R-p2+1</span></span><br><span class="line">rul+=a[p1]&lt;=a[p2]?(R-p2+<span class="number">1</span>)*a[p1]:<span class="number">0</span>;</span><br><span class="line">help[i++]=a[p1]&lt;=a[p2]?a[p1++]:a[p2++];<span class="comment">//每次选择小的数字存入数组 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左右两边的数量不是每次都相等，将剩下的元素也添加到help数组中 </span></span><br><span class="line"><span class="keyword">while</span>(p1&lt;=mid)</span><br><span class="line">&#123;</span><br><span class="line">help[i++]=a[p1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(p2&lt;=R)</span><br><span class="line">&#123;</span><br><span class="line">help[i++]=a[p2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;R-L+<span class="number">1</span>;i++)</span><br><span class="line">a[L+i]=help[i];</span><br><span class="line"><span class="keyword">return</span> rul;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
